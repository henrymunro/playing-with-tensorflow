{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-transforms/package.json","includedInParent":true,"mtime":1520278057000},{"name":"vega-dataflow","loc":{"line":1,"column":24}},{"name":"vega-statistics","loc":{"line":2,"column":18}},{"name":"vega-util","loc":{"line":3,"column":63}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Bin;\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaStatistics = require('vega-statistics');\n\nvar _vegaUtil = require('vega-util');\n\n/**\n * Generates a binning function for discretizing data.\n * @constructor\n * @param {object} params - The parameters for this operator. The\n *   provided values should be valid options for the {@link bin} function.\n * @param {function(object): *} params.field - The data field to bin.\n */\nfunction Bin(params) {\n  _vegaDataflow.Transform.call(this, null, params);\n}\n\nBin.Definition = {\n  \"type\": \"Bin\",\n  \"metadata\": { \"modifies\": true },\n  \"params\": [{ \"name\": \"field\", \"type\": \"field\", \"required\": true }, { \"name\": \"anchor\", \"type\": \"number\" }, { \"name\": \"maxbins\", \"type\": \"number\", \"default\": 20 }, { \"name\": \"base\", \"type\": \"number\", \"default\": 10 }, { \"name\": \"divide\", \"type\": \"number\", \"array\": true, \"default\": [5, 2] }, { \"name\": \"extent\", \"type\": \"number\", \"array\": true, \"length\": 2, \"required\": true }, { \"name\": \"step\", \"type\": \"number\" }, { \"name\": \"steps\", \"type\": \"number\", \"array\": true }, { \"name\": \"minstep\", \"type\": \"number\", \"default\": 0 }, { \"name\": \"nice\", \"type\": \"boolean\", \"default\": true }, { \"name\": \"name\", \"type\": \"string\" }, { \"name\": \"as\", \"type\": \"string\", \"array\": true, \"length\": 2, \"default\": [\"bin0\", \"bin1\"] }]\n};\n\nvar prototype = (0, _vegaUtil.inherits)(Bin, _vegaDataflow.Transform);\n\nprototype.transform = function (_, pulse) {\n  var bins = this._bins(_),\n      start = bins.start,\n      step = bins.step,\n      as = _.as || ['bin0', 'bin1'],\n      b0 = as[0],\n      b1 = as[1],\n      flag;\n\n  if (_.modified()) {\n    pulse = pulse.reflow(true);\n    flag = pulse.SOURCE;\n  } else {\n    flag = pulse.modified((0, _vegaUtil.accessorFields)(_.field)) ? pulse.ADD_MOD : pulse.ADD;\n  }\n\n  pulse.visit(flag, function (t) {\n    var v = bins(t);\n    // minimum bin value (inclusive)\n    t[b0] = v;\n    // maximum bin value (exclusive)\n    // use convoluted math for better floating point agreement\n    // see https://github.com/vega/vega/issues/830\n    t[b1] = v == null ? null : start + step * (1 + (v - start) / step);\n  });\n\n  return pulse.modifies(as);\n};\n\nprototype._bins = function (_) {\n  if (this.value && !_.modified()) {\n    return this.value;\n  }\n\n  var field = _.field,\n      bins = (0, _vegaStatistics.bin)(_),\n      start = bins.start,\n      stop = bins.stop,\n      step = bins.step,\n      a,\n      d;\n\n  if ((a = _.anchor) != null) {\n    d = a - (start + step * Math.floor((a - start) / step));\n    start += d;\n    stop += d;\n  }\n\n  var f = function (t) {\n    var v = field(t);\n    if (v == null) {\n      return null;\n    } else {\n      v = Math.max(start, Math.min(+v, stop - step));\n      return start + step * Math.floor((v - start) / step);\n    }\n  };\n\n  f.start = start;\n  f.stop = stop;\n  f.step = step;\n\n  return this.value = (0, _vegaUtil.accessor)(f, (0, _vegaUtil.accessorFields)(field), _.name || 'bin_' + (0, _vegaUtil.accessorName)(field));\n};"},"hash":"09655bf5797b48c3db24502a0ba8c1ee","cacheData":{"env":{}}}