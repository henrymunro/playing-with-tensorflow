{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-crossfilter/package.json","includedInParent":true,"mtime":1501881708000},{"name":"./Bitmaps","loc":{"line":1,"column":20}},{"name":"./Dimension","loc":{"line":2,"column":22}},{"name":"./SortedIndex","loc":{"line":3,"column":24}},{"name":"vega-dataflow","loc":{"line":4,"column":24}},{"name":"vega-util","loc":{"line":5,"column":23}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = CrossFilter;\n\nvar _Bitmaps = require('./Bitmaps');\n\nvar _Bitmaps2 = _interopRequireDefault(_Bitmaps);\n\nvar _Dimension = require('./Dimension');\n\nvar _Dimension2 = _interopRequireDefault(_Dimension);\n\nvar _SortedIndex = require('./SortedIndex');\n\nvar _SortedIndex2 = _interopRequireDefault(_SortedIndex);\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaUtil = require('vega-util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\nfunction CrossFilter(params) {\n  _vegaDataflow.Transform.call(this, (0, _Bitmaps2.default)(), params);\n  this._indices = null;\n  this._dims = null;\n}\n\nCrossFilter.Definition = {\n  \"type\": \"CrossFilter\",\n  \"metadata\": {},\n  \"params\": [{ \"name\": \"fields\", \"type\": \"field\", \"array\": true, \"required\": true }, { \"name\": \"query\", \"type\": \"array\", \"array\": true, \"required\": true,\n    \"content\": { \"type\": \"number\", \"array\": true, \"length\": 2 } }]\n};\n\nvar prototype = (0, _vegaUtil.inherits)(CrossFilter, _vegaDataflow.Transform);\n\nprototype.transform = function (_, pulse) {\n  if (!this._dims) {\n    return this.init(_, pulse);\n  } else {\n    var init = _.modified('fields') || _.fields.some(function (f) {\n      return pulse.modified(f.fields);\n    });\n\n    return init ? this.reinit(_, pulse) : this.eval(_, pulse);\n  }\n};\n\nprototype.init = function (_, pulse) {\n  var fields = _.fields,\n      query = _.query,\n      indices = this._indices = {},\n      dims = this._dims = [],\n      m = query.length,\n      i = 0,\n      key,\n      index;\n\n  // instantiate indices and dimensions\n  for (; i < m; ++i) {\n    key = fields[i].fname;\n    index = indices[key] || (indices[key] = (0, _SortedIndex2.default)());\n    dims.push((0, _Dimension2.default)(index, i, query[i]));\n  }\n\n  return this.eval(_, pulse);\n};\n\nprototype.reinit = function (_, pulse) {\n  var output = pulse.materialize().fork(),\n      fields = _.fields,\n      query = _.query,\n      indices = this._indices,\n      dims = this._dims,\n      bits = this.value,\n      curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all(),\n      out = output.rem = output.add,\n      mod = output.mod,\n      m = query.length,\n      adds = {},\n      add,\n      index,\n      key,\n      mods,\n      remMap,\n      modMap,\n      i,\n      n,\n      f;\n\n  // set prev to current state\n  prev.set(curr);\n\n  // if pulse has remove tuples, process them first\n  if (pulse.rem.length) {\n    remMap = this.remove(_, pulse, output);\n  }\n\n  // if pulse has added tuples, add them to state\n  if (pulse.add.length) {\n    bits.add(pulse.add);\n  }\n\n  // if pulse has modified tuples, create an index map\n  if (pulse.mod.length) {\n    modMap = {};\n    for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {\n      modMap[mods[i]._index] = 1;\n    }\n  }\n\n  // re-initialize indices as needed, update curr bitmap\n  for (i = 0; i < m; ++i) {\n    f = fields[i];\n    if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n      key = f.fname;\n      if (!(add = adds[key])) {\n        indices[key] = index = (0, _SortedIndex2.default)();\n        adds[key] = add = index.insert(f, pulse.source, 0);\n      }\n      dims[i] = (0, _Dimension2.default)(index, i, query[i]).onAdd(add, curr);\n    }\n  }\n\n  // visit each tuple\n  // if filter state changed, push index to add/rem\n  // else if in mod and passes a filter, push index to mod\n  for (i = 0, n = bits.data().length; i < n; ++i) {\n    if (remMap[i]) {\n      // skip if removed tuple\n      continue;\n    } else if (prev[i] !== curr[i]) {\n      // add if state changed\n      out.push(i);\n    } else if (modMap[i] && curr[i] !== all) {\n      // otherwise, pass mods through\n      mod.push(i);\n    }\n  }\n\n  bits.mask = (1 << m) - 1;\n  return output;\n};\n\nprototype.eval = function (_, pulse) {\n  var output = pulse.materialize().fork(),\n      m = this._dims.length,\n      mask = 0;\n\n  if (pulse.rem.length) {\n    this.remove(_, pulse, output);\n    mask |= (1 << m) - 1;\n  }\n\n  if (_.modified('query') && !_.modified('fields')) {\n    mask |= this.update(_, pulse, output);\n  }\n\n  if (pulse.add.length) {\n    this.insert(_, pulse, output);\n    mask |= (1 << m) - 1;\n  }\n\n  if (pulse.mod.length) {\n    this.modify(pulse, output);\n    mask |= (1 << m) - 1;\n  }\n\n  this.value.mask = mask;\n  return output;\n};\n\nprototype.insert = function (_, pulse, output) {\n  var tuples = pulse.add,\n      bits = this.value,\n      dims = this._dims,\n      indices = this._indices,\n      fields = _.fields,\n      adds = {},\n      out = output.add,\n      k = bits.size(),\n      n = k + tuples.length,\n      m = dims.length,\n      j,\n      key,\n      add;\n\n  // resize bitmaps and add tuples as needed\n  bits.resize(n, m);\n  bits.add(tuples);\n\n  var curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all();\n\n  // add to dimensional indices\n  for (j = 0; j < m; ++j) {\n    key = fields[j].fname;\n    add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n    dims[j].onAdd(add, curr);\n  }\n\n  // set previous filters, output if passes at least one filter\n  for (; k < n; ++k) {\n    prev[k] = all;\n    if (curr[k] !== all) out.push(k);\n  }\n};\n\nprototype.modify = function (pulse, output) {\n  var out = output.mod,\n      bits = this.value,\n      curr = bits.curr(),\n      all = bits.all(),\n      tuples = pulse.mod,\n      i,\n      n,\n      k;\n\n  for (i = 0, n = tuples.length; i < n; ++i) {\n    k = tuples[i]._index;\n    if (curr[k] !== all) out.push(k);\n  }\n};\n\nprototype.remove = function (_, pulse, output) {\n  var indices = this._indices,\n      bits = this.value,\n      curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all(),\n      map = {},\n      out = output.rem,\n      tuples = pulse.rem,\n      i,\n      n,\n      k,\n      f;\n\n  // process tuples, output if passes at least one filter\n  for (i = 0, n = tuples.length; i < n; ++i) {\n    k = tuples[i]._index;\n    map[k] = 1; // build index map\n    prev[k] = f = curr[k];\n    curr[k] = all;\n    if (f !== all) out.push(k);\n  }\n\n  // remove from dimensional indices\n  for (k in indices) {\n    indices[k].remove(n, map);\n  }\n\n  this.reindex(pulse, n, map);\n  return map;\n};\n\n// reindex filters and indices after propagation completes\nprototype.reindex = function (pulse, num, map) {\n  var indices = this._indices,\n      bits = this.value;\n\n  pulse.runAfter(function () {\n    var indexMap = bits.remove(num, map);\n    for (var key in indices) indices[key].reindex(indexMap);\n  });\n};\n\nprototype.update = function (_, pulse, output) {\n  var dims = this._dims,\n      query = _.query,\n      stamp = pulse.stamp,\n      m = dims.length,\n      mask = 0,\n      i,\n      q;\n\n  // survey how many queries have changed\n  output.filters = 0;\n  for (q = 0; q < m; ++q) {\n    if (_.modified('query', q)) {\n      i = q;++mask;\n    }\n  }\n\n  if (mask === 1) {\n    // only one query changed, use more efficient update\n    mask = dims[i].one;\n    this.incrementOne(dims[i], query[i], output.add, output.rem);\n  } else {\n    // multiple queries changed, perform full record keeping\n    for (q = 0, mask = 0; q < m; ++q) {\n      if (!_.modified('query', q)) continue;\n      mask |= dims[q].one;\n      this.incrementAll(dims[q], query[q], stamp, output.add);\n      output.rem = output.add; // duplicate add/rem for downstream resolve\n    }\n  }\n\n  return mask;\n};\n\nprototype.incrementAll = function (dim, query, stamp, out) {\n  var bits = this.value,\n      seen = bits.seen(),\n      curr = bits.curr(),\n      prev = bits.prev(),\n      index = dim.index(),\n      old = dim.bisect(dim.range),\n      range = dim.bisect(query),\n      lo1 = range[0],\n      hi1 = range[1],\n      lo0 = old[0],\n      hi0 = old[1],\n      one = dim.one,\n      i,\n      j,\n      k;\n\n  // Fast incremental update based on previous lo index.\n  if (lo1 < lo0) {\n    for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n      k = index[i];\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n      curr[k] ^= one;\n    }\n  } else if (lo1 > lo0) {\n    for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n      k = index[i];\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n      curr[k] ^= one;\n    }\n  }\n\n  // Fast incremental update based on previous hi index.\n  if (hi1 > hi0) {\n    for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n      k = index[i];\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n      curr[k] ^= one;\n    }\n  } else if (hi1 < hi0) {\n    for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n      k = index[i];\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n      curr[k] ^= one;\n    }\n  }\n\n  dim.range = query.slice();\n};\n\nprototype.incrementOne = function (dim, query, add, rem) {\n  var bits = this.value,\n      curr = bits.curr(),\n      index = dim.index(),\n      old = dim.bisect(dim.range),\n      range = dim.bisect(query),\n      lo1 = range[0],\n      hi1 = range[1],\n      lo0 = old[0],\n      hi0 = old[1],\n      one = dim.one,\n      i,\n      j,\n      k;\n\n  // Fast incremental update based on previous lo index.\n  if (lo1 < lo0) {\n    for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      add.push(k);\n    }\n  } else if (lo1 > lo0) {\n    for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      rem.push(k);\n    }\n  }\n\n  // Fast incremental update based on previous hi index.\n  if (hi1 > hi0) {\n    for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      add.push(k);\n    }\n  } else if (hi1 < hi0) {\n    for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      rem.push(k);\n    }\n  }\n\n  dim.range = query.slice();\n};"},"hash":"27534c16566ebf100e7bde0f9736040e","cacheData":{"env":{}}}