{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-dataflow/package.json","includedInParent":true,"mtime":1518291445000},{"name":"./Parameters","loc":{"line":1,"column":23}},{"name":"./util/UniqueList","loc":{"line":2,"column":23}},{"name":"vega-util","loc":{"line":3,"column":40}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Operator;\n\nvar _Parameters = require('./Parameters');\n\nvar _Parameters2 = _interopRequireDefault(_Parameters);\n\nvar _UniqueList = require('./util/UniqueList');\n\nvar _UniqueList2 = _interopRequireDefault(_UniqueList);\n\nvar _vegaUtil = require('vega-util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar OP_ID = 0;\nvar PULSE = 'pulse';\nvar NO_PARAMS = new _Parameters2.default();\n\n// Boolean Flags\nvar SKIP = 1,\n    MODIFIED = 2;\n\n/**\n * An Operator is a processing node in a dataflow graph.\n * Each operator stores a value and an optional value update function.\n * Operators can accept a hash of named parameters. Parameter values can\n * either be direct (JavaScript literals, arrays, objects) or indirect\n * (other operators whose values will be pulled dynamically). Operators\n * included as parameters will have this operator added as a dependency.\n * @constructor\n * @param {*} [init] - The initial value for this operator.\n * @param {function(object, Pulse)} [update] - An update function. Upon\n *   evaluation of this operator, the update function will be invoked and the\n *   return value will be used as the new value of this operator.\n * @param {object} [params] - The parameters for this operator.\n * @param {boolean} [react=true] - Flag indicating if this operator should\n *   listen for changes to upstream operators included as parameters.\n * @see parameters\n */\nfunction Operator(init, update, params, react) {\n  this.id = ++OP_ID;\n  this.value = init;\n  this.stamp = -1;\n  this.rank = -1;\n  this.qrank = -1;\n  this.flags = 0;\n\n  if (update) {\n    this._update = update;\n  }\n  if (params) this.parameters(params, react);\n}\n\nvar prototype = Operator.prototype;\n\n/**\n * Returns a list of target operators dependent on this operator.\n * If this list does not exist, it is created and then returned.\n * @return {UniqueList}\n */\nprototype.targets = function () {\n  return this._targets || (this._targets = (0, _UniqueList2.default)(_vegaUtil.id));\n};\n\n/**\n * Sets the value of this operator.\n * @param {*} value - the value to set.\n * @return {Number} Returns 1 if the operator value has changed\n *   according to strict equality, returns 0 otherwise.\n */\nprototype.set = function (value) {\n  if (this.value !== value) {\n    this.value = value;\n    return 1;\n  } else {\n    return 0;\n  }\n};\n\nfunction flag(bit) {\n  return function (state) {\n    var f = this.flags;\n    if (arguments.length === 0) return !!(f & bit);\n    this.flags = state ? f | bit : f & ~bit;\n    return this;\n  };\n}\n\n/**\n * Indicates that operator evaluation should be skipped on the next pulse.\n * This operator will still propagate incoming pulses, but its update function\n * will not be invoked. The skip flag is reset after every pulse, so calling\n * this method will affect processing of the next pulse only.\n */\nprototype.skip = flag(SKIP);\n\n/**\n * Indicates that this operator's value has been modified on its most recent\n * pulse. Normally modification is checked via strict equality; however, in\n * some cases it is more efficient to update the internal state of an object.\n * In those cases, the modified flag can be used to trigger propagation. Once\n * set, the modification flag persists across pulses until unset. The flag can\n * be used with the last timestamp to test if a modification is recent.\n */\nprototype.modified = flag(MODIFIED);\n\n/**\n * Sets the parameters for this operator. The parameter values are analyzed for\n * operator instances. If found, this operator will be added as a dependency\n * of the parameterizing operator. Operator values are dynamically marshalled\n * from each operator parameter prior to evaluation. If a parameter value is\n * an array, the array will also be searched for Operator instances. However,\n * the search does not recurse into sub-arrays or object properties.\n * @param {object} params - A hash of operator parameters.\n * @param {boolean} [react=true] - A flag indicating if this operator should\n *   automatically update (react) when parameter values change. In other words,\n *   this flag determines if the operator registers itself as a listener on\n *   any upstream operators included in the parameters.\n * @return {Operator[]} - An array of upstream dependencies.\n */\nprototype.parameters = function (params, react) {\n  react = react !== false;\n  var self = this,\n      argval = self._argval = self._argval || new _Parameters2.default(),\n      argops = self._argops = self._argops || [],\n      deps = [],\n      name,\n      value,\n      n,\n      i;\n\n  function add(name, index, value) {\n    if (value instanceof Operator) {\n      if (value !== self) {\n        if (react) value.targets().add(self);\n        deps.push(value);\n      }\n      argops.push({ op: value, name: name, index: index });\n    } else {\n      argval.set(name, index, value);\n    }\n  }\n\n  for (name in params) {\n    value = params[name];\n\n    if (name === PULSE) {\n      (0, _vegaUtil.array)(value).forEach(function (op) {\n        if (!(op instanceof Operator)) {\n          (0, _vegaUtil.error)('Pulse parameters must be operator instances.');\n        } else if (op !== self) {\n          op.targets().add(self);\n          deps.push(op);\n        }\n      });\n      self.source = value;\n    } else if ((0, _vegaUtil.isArray)(value)) {\n      argval.set(name, -1, Array(n = value.length));\n      for (i = 0; i < n; ++i) add(name, i, value[i]);\n    } else {\n      add(name, -1, value);\n    }\n  }\n\n  this.marshall().clear(); // initialize values\n  return deps;\n};\n\n/**\n * Internal method for marshalling parameter values.\n * Visits each operator dependency to pull the latest value.\n * @return {Parameters} A Parameters object to pass to the update function.\n */\nprototype.marshall = function (stamp) {\n  var argval = this._argval || NO_PARAMS,\n      argops = this._argops,\n      item,\n      i,\n      n,\n      op,\n      mod;\n\n  if (argops && (n = argops.length)) {\n    for (i = 0; i < n; ++i) {\n      item = argops[i];\n      op = item.op;\n      mod = op.modified() && op.stamp === stamp;\n      argval.set(item.name, item.index, op.value, mod);\n    }\n  }\n  return argval;\n};\n\n/**\n * Delegate method to perform operator processing.\n * Subclasses can override this method to perform custom processing.\n * By default, it marshalls parameters and calls the update function\n * if that function is defined. If the update function does not\n * change the operator value then StopPropagation is returned.\n * If no update function is defined, this method does nothing.\n * @param {Pulse} pulse - the current dataflow pulse.\n * @return The output pulse or StopPropagation. A falsy return value\n *   (including undefined) will let the input pulse pass through.\n */\nprototype.evaluate = function (pulse) {\n  if (this._update) {\n    var params = this.marshall(pulse.stamp),\n        v = this._update(params, pulse);\n\n    params.clear();\n    if (v !== this.value) {\n      this.value = v;\n    } else if (!this.modified()) {\n      return pulse.StopPropagation;\n    }\n  }\n};\n\n/**\n * Run this operator for the current pulse. If this operator has already\n * been run at (or after) the pulse timestamp, returns StopPropagation.\n * Internally, this method calls {@link evaluate} to perform processing.\n * If {@link evaluate} returns a falsy value, the input pulse is returned.\n * This method should NOT be overridden, instead overrride {@link evaluate}.\n * @param {Pulse} pulse - the current dataflow pulse.\n * @return the output pulse for this operator (or StopPropagation)\n */\nprototype.run = function (pulse) {\n  if (pulse.stamp <= this.stamp) return pulse.StopPropagation;\n  var rv;\n  if (this.skip()) {\n    this.skip(false);\n    rv = 0;\n  } else {\n    rv = this.evaluate(pulse);\n  }\n  this.stamp = pulse.stamp;\n  this.pulse = rv;\n  return rv || pulse;\n};"},"hash":"bbc9f2c7e42e8baf4c6d10b83402ab1a","cacheData":{"env":{}}}