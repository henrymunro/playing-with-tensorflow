{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-scenegraph/package.json","includedInParent":true,"mtime":1518728314000},{"name":"./Renderer","loc":{"line":1,"column":21}},{"name":"./marks/index","loc":{"line":2,"column":18}},{"name":"./util/dom","loc":{"line":3,"column":54}},{"name":"./util/tags","loc":{"line":4,"column":32}},{"name":"./util/text","loc":{"line":5,"column":30}},{"name":"./util/visit","loc":{"line":6,"column":20}},{"name":"./util/svg/clip","loc":{"line":7,"column":17}},{"name":"./util/svg/metadata","loc":{"line":8,"column":21}},{"name":"./util/svg/styles","loc":{"line":9,"column":38}},{"name":"vega-util","loc":{"line":10,"column":23}},{"name":"process"}],"generated":{"js":"var process = require(\"process\");\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = SVGRenderer;\n\nvar _Renderer = require('./Renderer');\n\nvar _Renderer2 = _interopRequireDefault(_Renderer);\n\nvar _index = require('./marks/index');\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _dom = require('./util/dom');\n\nvar _tags = require('./util/tags');\n\nvar _text = require('./util/text');\n\nvar _visit = require('./util/visit');\n\nvar _clip = require('./util/svg/clip');\n\nvar _clip2 = _interopRequireDefault(_clip);\n\nvar _metadata = require('./util/svg/metadata');\n\nvar _metadata2 = _interopRequireDefault(_metadata);\n\nvar _styles = require('./util/svg/styles');\n\nvar _vegaUtil = require('vega-util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ns = _metadata2.default.xmlns;\n\nfunction SVGRenderer(loader) {\n  _Renderer2.default.call(this, loader);\n  this._dirtyID = 1;\n  this._dirty = [];\n  this._svg = null;\n  this._root = null;\n  this._defs = null;\n}\n\nvar prototype = (0, _vegaUtil.inherits)(SVGRenderer, _Renderer2.default);\nvar base = _Renderer2.default.prototype;\n\nprototype.initialize = function (el, width, height, padding) {\n  if (el) {\n    this._svg = (0, _dom.domChild)(el, 0, 'svg', ns);\n    this._svg.setAttribute('class', 'marks');\n    (0, _dom.domClear)(el, 1);\n    // set the svg root group\n    this._root = (0, _dom.domChild)(this._svg, 0, 'g', ns);\n    (0, _dom.domClear)(this._svg, 1);\n  }\n\n  // create the svg definitions cache\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n\n  // set background color if defined\n  this.background(this._bgcolor);\n\n  return base.initialize.call(this, el, width, height, padding);\n};\n\nprototype.background = function (bgcolor) {\n  if (arguments.length && this._svg) {\n    this._svg.style.setProperty('background-color', bgcolor);\n  }\n  return base.background.apply(this, arguments);\n};\n\nprototype.resize = function (width, height, origin, scaleFactor) {\n  base.resize.call(this, width, height, origin, scaleFactor);\n\n  if (this._svg) {\n    this._svg.setAttribute('width', this._width * this._scale);\n    this._svg.setAttribute('height', this._height * this._scale);\n    this._svg.setAttribute('viewBox', '0 0 ' + this._width + ' ' + this._height);\n    this._root.setAttribute('transform', 'translate(' + this._origin + ')');\n  }\n\n  this._dirty = [];\n\n  return this;\n};\n\nprototype.svg = function () {\n  if (!this._svg) return null;\n\n  var attr = {\n    class: 'marks',\n    width: this._width * this._scale,\n    height: this._height * this._scale,\n    viewBox: '0 0 ' + this._width + ' ' + this._height\n  };\n  for (var key in _metadata2.default) {\n    attr[key] = _metadata2.default[key];\n  }\n\n  var bg = !this._bgcolor ? '' : (0, _tags.openTag)('rect', {\n    width: this._width,\n    height: this._height,\n    style: 'fill: ' + this._bgcolor + ';'\n  }) + (0, _tags.closeTag)('rect');\n\n  return (0, _tags.openTag)('svg', attr) + bg + this._svg.innerHTML + (0, _tags.closeTag)('svg');\n};\n\n// -- Render entry point --\n\nprototype._render = function (scene) {\n  // perform spot updates and re-render markup\n  if (this._dirtyCheck()) {\n    if (this._dirtyAll) this._resetDefs();\n    this.draw(this._root, scene);\n    (0, _dom.domClear)(this._root, 1);\n  }\n\n  this.updateDefs();\n\n  this._dirty = [];\n  ++this._dirtyID;\n\n  return this;\n};\n\n// -- Manage SVG definitions ('defs') block --\n\nprototype.updateDefs = function () {\n  var svg = this._svg,\n      defs = this._defs,\n      el = defs.el,\n      index = 0,\n      id;\n\n  for (id in defs.gradient) {\n    if (!el) defs.el = el = (0, _dom.domChild)(svg, 0, 'defs', ns);\n    updateGradient(el, defs.gradient[id], index++);\n  }\n\n  for (id in defs.clipping) {\n    if (!el) defs.el = el = (0, _dom.domChild)(svg, 0, 'defs', ns);\n    updateClipping(el, defs.clipping[id], index++);\n  }\n\n  // clean-up\n  if (el) {\n    if (index === 0) {\n      svg.removeChild(el);\n      defs.el = null;\n    } else {\n      (0, _dom.domClear)(el, index);\n    }\n  }\n};\n\nfunction updateGradient(el, grad, index) {\n  var i, n, stop;\n\n  el = (0, _dom.domChild)(el, index, 'linearGradient', ns);\n  el.setAttribute('id', grad.id);\n  el.setAttribute('x1', grad.x1);\n  el.setAttribute('x2', grad.x2);\n  el.setAttribute('y1', grad.y1);\n  el.setAttribute('y2', grad.y2);\n\n  for (i = 0, n = grad.stops.length; i < n; ++i) {\n    stop = (0, _dom.domChild)(el, i, 'stop', ns);\n    stop.setAttribute('offset', grad.stops[i].offset);\n    stop.setAttribute('stop-color', grad.stops[i].color);\n  }\n  (0, _dom.domClear)(el, i);\n}\n\nfunction updateClipping(el, clip, index) {\n  var mask;\n\n  el = (0, _dom.domChild)(el, index, 'clipPath', ns);\n  el.setAttribute('id', clip.id);\n\n  if (clip.path) {\n    mask = (0, _dom.domChild)(el, 0, 'path', ns);\n    mask.setAttribute('d', clip.path);\n  } else {\n    mask = (0, _dom.domChild)(el, 0, 'rect', ns);\n    mask.setAttribute('x', 0);\n    mask.setAttribute('y', 0);\n    mask.setAttribute('width', clip.width);\n    mask.setAttribute('height', clip.height);\n  }\n}\n\nprototype._resetDefs = function () {\n  var def = this._defs;\n  def.gradient = {};\n  def.clipping = {};\n};\n\n// -- Manage rendering of items marked as dirty --\n\nprototype.dirty = function (item) {\n  if (item.dirty !== this._dirtyID) {\n    item.dirty = this._dirtyID;\n    this._dirty.push(item);\n  }\n};\n\nprototype.isDirty = function (item) {\n  return this._dirtyAll || !item._svg || item.dirty === this._dirtyID;\n};\n\nprototype._dirtyCheck = function () {\n  this._dirtyAll = true;\n  var items = this._dirty;\n  if (!items.length) return true;\n\n  var id = ++this._dirtyID,\n      item,\n      mark,\n      type,\n      mdef,\n      i,\n      n,\n      o;\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    item = items[i];\n    mark = item.mark;\n\n    if (mark.marktype !== type) {\n      // memoize mark instance lookup\n      type = mark.marktype;\n      mdef = _index2.default[type];\n    }\n\n    if (mark.zdirty && mark.dirty !== id) {\n      this._dirtyAll = false;\n      mark.dirty = id;\n      dirtyParents(mark.group, id);\n    }\n\n    if (item.exit) {\n      // EXIT\n      if (mdef.nested && mark.items.length) {\n        // if nested mark with remaining points, update instead\n        o = mark.items[0];\n        if (o._svg) this._update(mdef, o._svg, o);\n      } else if (item._svg) {\n        // otherwise remove from DOM\n        o = item._svg.parentNode;\n        if (o) o.removeChild(item._svg);\n      }\n      item._svg = null;\n      continue;\n    }\n\n    item = mdef.nested ? mark.items[0] : item;\n    if (item._update === id) continue; // already visited\n\n    if (!item._svg || !item._svg.ownerSVGElement) {\n      // ENTER\n      this._dirtyAll = false;\n      dirtyParents(item, id);\n    } else {\n      // IN-PLACE UPDATE\n      this._update(mdef, item._svg, item);\n    }\n    item._update = id;\n  }\n  return !this._dirtyAll;\n};\n\nfunction dirtyParents(item, id) {\n  for (; item && item.dirty !== id; item = item.mark.group) {\n    item.dirty = id;\n    if (item.mark && item.mark.dirty !== id) {\n      item.mark.dirty = id;\n    } else return;\n  }\n}\n\n// -- Construct & maintain scenegraph to SVG mapping ---\n\n// Draw a mark container.\nprototype.draw = function (el, scene, prev) {\n  if (!this.isDirty(scene)) return scene._svg;\n\n  var renderer = this,\n      mdef = _index2.default[scene.marktype],\n      events = scene.interactive === false ? 'none' : null,\n      isGroup = mdef.tag === 'g',\n      sibling = null,\n      i = 0,\n      parent;\n\n  parent = bind(scene, el, prev, 'g');\n  parent.setAttribute('class', (0, _dom.cssClass)(scene));\n  if (!isGroup) {\n    parent.style.setProperty('pointer-events', events);\n  }\n  if (scene.clip) {\n    parent.setAttribute('clip-path', (0, _clip2.default)(renderer, scene, scene.group));\n  } else {\n    parent.removeAttribute('clip-path');\n  }\n\n  function process(item) {\n    var dirty = renderer.isDirty(item),\n        node = bind(item, parent, sibling, mdef.tag);\n\n    if (dirty) {\n      renderer._update(mdef, node, item);\n      if (isGroup) recurse(renderer, node, item);\n    }\n\n    sibling = node;\n    ++i;\n  }\n\n  if (mdef.nested) {\n    if (scene.items.length) process(scene.items[0]);\n  } else {\n    (0, _visit.visit)(scene, process);\n  }\n\n  (0, _dom.domClear)(parent, i);\n  return parent;\n};\n\n// Recursively process group contents.\nfunction recurse(renderer, el, group) {\n  el = el.lastChild;\n  var prev,\n      idx = 0;\n\n  (0, _visit.visit)(group, function (item) {\n    prev = renderer.draw(el, item, prev);\n    ++idx;\n  });\n\n  // remove any extraneous DOM elements\n  (0, _dom.domClear)(el, 1 + idx);\n}\n\n// Bind a scenegraph item to an SVG DOM element.\n// Create new SVG elements as needed.\nfunction bind(item, el, sibling, tag) {\n  var node = item._svg,\n      doc;\n\n  // create a new dom node if needed\n  if (!node) {\n    doc = el.ownerDocument;\n    node = (0, _dom.domCreate)(doc, tag, ns);\n    item._svg = node;\n\n    if (item.mark) {\n      node.__data__ = item;\n      node.__values__ = { fill: 'default' };\n\n      // if group, create background and foreground elements\n      if (tag === 'g') {\n        var bg = (0, _dom.domCreate)(doc, 'path', ns);\n        bg.setAttribute('class', 'background');\n        node.appendChild(bg);\n        bg.__data__ = item;\n\n        var fg = (0, _dom.domCreate)(doc, 'g', ns);\n        node.appendChild(fg);\n        fg.__data__ = item;\n      }\n    }\n  }\n\n  if (doc || node.previousSibling !== sibling || !sibling) {\n    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);\n  }\n\n  return node;\n}\n\n// -- Set attributes & styles on SVG elements ---\n\nvar element = null,\n    // temp var for current SVG element\nvalues = null; // temp var for current values hash\n\n// Extra configuration for certain mark types\nvar mark_extras = {\n  group: function (mdef, el, item) {\n    values = el.__values__; // use parent's values hash\n\n    element = el.childNodes[1];\n    mdef.foreground(emit, item, this);\n\n    element = el.childNodes[0];\n    mdef.background(emit, item, this);\n\n    var value = item.mark.interactive === false ? 'none' : null;\n    if (value !== values.events) {\n      element.style.setProperty('pointer-events', value);\n      values.events = value;\n    }\n  },\n  text: function (mdef, el, item) {\n    var str = (0, _text.textValue)(item);\n    if (str !== values.text) {\n      el.textContent = str;\n      values.text = str;\n    }\n    str = (0, _text.font)(item);\n    if (str !== values.font) {\n      el.style.setProperty('font', str);\n      values.font = str;\n    }\n  }\n};\n\nprototype._update = function (mdef, el, item) {\n  // set dom element and values cache\n  // provides access to emit method\n  element = el;\n  values = el.__values__;\n\n  // apply svg attributes\n  mdef.attr(emit, item, this);\n\n  // some marks need special treatment\n  var extra = mark_extras[mdef.type];\n  if (extra) extra.call(this, mdef, el, item);\n\n  // apply svg css styles\n  // note: element may be modified by 'extra' method\n  this.style(element, item);\n};\n\nfunction emit(name, value, ns) {\n  // early exit if value is unchanged\n  if (value === values[name]) return;\n\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    if (ns) {\n      element.setAttributeNS(ns, name, value);\n    } else {\n      element.setAttribute(name, value);\n    }\n  } else {\n    // else remove DOM attribute\n    if (ns) {\n      element.removeAttributeNS(ns, name);\n    } else {\n      element.removeAttribute(name);\n    }\n  }\n\n  // note current value for future comparison\n  values[name] = value;\n}\n\nprototype.style = function (el, o) {\n  if (o == null) return;\n  var i, n, prop, name, value;\n\n  for (i = 0, n = _styles.styleProperties.length; i < n; ++i) {\n    prop = _styles.styleProperties[i];\n    value = o[prop];\n    if (value === values[prop]) continue;\n\n    name = _styles.styles[prop];\n    if (value == null) {\n      if (name === 'fill') {\n        el.style.setProperty(name, 'none');\n      } else {\n        el.style.removeProperty(name);\n      }\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        this._defs.gradient[value.id] = value;\n        value = 'url(' + href() + '#' + value.id + ')';\n      }\n      el.style.setProperty(name, value + '');\n    }\n\n    values[prop] = value;\n  }\n};\n\nfunction href() {\n  var loc;\n  return typeof window === 'undefined' ? '' : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;\n}"},"hash":"a22014e930089004dabe9a6bf5cc804f","cacheData":{"env":{}}}