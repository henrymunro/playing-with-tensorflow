{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-parser/package.json","includedInParent":true,"mtime":1520359126000},{"name":"./guides/legend-gradient","loc":{"line":1,"column":27}},{"name":"./guides/legend-gradient-labels","loc":{"line":2,"column":33}},{"name":"./guides/legend-labels","loc":{"line":3,"column":25}},{"name":"./guides/legend-symbols","loc":{"line":4,"column":26}},{"name":"./guides/legend-title","loc":{"line":5,"column":24}},{"name":"./guides/guide-group","loc":{"line":6,"column":23}},{"name":"./mark","loc":{"line":7,"column":22}},{"name":"./marks/roles","loc":{"line":8,"column":42}},{"name":"./encode/encode-util","loc":{"line":9,"column":47}},{"name":"./guides/constants","loc":{"line":10,"column":53}},{"name":"../util","loc":{"line":11,"column":25}},{"name":"../transforms","loc":{"line":12,"column":37}},{"name":"vega-util","loc":{"line":13,"column":20}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (spec, scope) {\n  var type = spec.type || 'symbol',\n      config = scope.config.legend,\n      encode = spec.encode || {},\n      legendEncode = encode.legend || {},\n      name = legendEncode.name || undefined,\n      interactive = legendEncode.interactive,\n      style = legendEncode.style,\n      datum,\n      dataRef,\n      entryRef,\n      group,\n      title,\n      entryEncode,\n      params,\n      children;\n\n  // resolve 'canonical' scale name\n  var scale = spec.size || spec.shape || spec.fill || spec.stroke || spec.strokeDash || spec.opacity;\n\n  if (!scale) {\n    (0, _vegaUtil.error)('Missing valid scale for legend.');\n  }\n\n  // single-element data source for axis group\n  datum = {\n    orient: (0, _util.value)(spec.orient, config.orient),\n    title: spec.title != null\n  };\n  dataRef = (0, _util.ref)(scope.add((0, _transforms.Collect)(null, [datum])));\n\n  // encoding properties for legend group\n\n  legendEncode = (0, _encodeUtil.extendEncode)({\n    enter: legendEnter(config),\n    update: {\n      offset: (0, _encodeUtil.encoder)((0, _util.value)(spec.offset, config.offset)),\n      padding: (0, _encodeUtil.encoder)((0, _util.value)(spec.padding, config.padding)),\n      titlePadding: (0, _encodeUtil.encoder)((0, _util.value)(spec.titlePadding, config.titlePadding))\n    }\n  }, legendEncode, _constants.Skip);\n\n  // encoding properties for legend entry sub-group\n  entryEncode = {\n    update: {\n      x: { field: { group: 'padding' } },\n      y: { field: { group: 'padding' } },\n      entryPadding: (0, _encodeUtil.encoder)((0, _util.value)(spec.entryPadding, config.entryPadding))\n    }\n  };\n\n  if (type === 'gradient') {\n    // data source for gradient labels\n    entryRef = (0, _util.ref)(scope.add((0, _transforms.LegendEntries)({\n      type: 'gradient',\n      scale: scope.scaleRef(scale),\n      count: scope.objectProperty(spec.tickCount),\n      values: scope.objectProperty(spec.values),\n      formatSpecifier: scope.property(spec.format)\n    })));\n\n    children = [(0, _legendGradient2.default)(spec, scale, config, encode.gradient), (0, _legendGradientLabels2.default)(spec, config, encode.labels, entryRef)];\n  } else {\n    // data source for legend entries\n    entryRef = (0, _util.ref)(scope.add((0, _transforms.LegendEntries)(params = {\n      scale: scope.scaleRef(scale),\n      count: scope.objectProperty(spec.tickCount),\n      values: scope.objectProperty(spec.values),\n      formatSpecifier: scope.property(spec.format)\n    })));\n\n    children = [(0, _legendSymbols2.default)(spec, config, encode.symbols, entryRef), (0, _legendLabels2.default)(spec, config, encode.labels, entryRef)];\n\n    params.size = sizeExpression(spec, scope, children);\n  }\n\n  // generate legend marks\n  children = [(0, _guideGroup2.default)(_roles.LegendEntryRole, null, null, dataRef, interactive, entryEncode, children)];\n\n  // include legend title if defined\n  if (datum.title) {\n    title = (0, _legendTitle2.default)(spec, config, encode.title, dataRef);\n    entryEncode.update.y.offset = {\n      field: { group: 'titlePadding' },\n      offset: getValue(scope, title.encode, 'fontSize', _constants.GuideTitleStyle)\n    };\n    children.push(title);\n  }\n\n  // build legend specification\n  group = (0, _guideGroup2.default)(_roles.LegendRole, style, name, dataRef, interactive, legendEncode, children);\n  if (spec.zindex) group.zindex = spec.zindex;\n\n  // parse legend specification\n  return (0, _mark2.default)(group, scope);\n};\n\nvar _legendGradient = require('./guides/legend-gradient');\n\nvar _legendGradient2 = _interopRequireDefault(_legendGradient);\n\nvar _legendGradientLabels = require('./guides/legend-gradient-labels');\n\nvar _legendGradientLabels2 = _interopRequireDefault(_legendGradientLabels);\n\nvar _legendLabels = require('./guides/legend-labels');\n\nvar _legendLabels2 = _interopRequireDefault(_legendLabels);\n\nvar _legendSymbols = require('./guides/legend-symbols');\n\nvar _legendSymbols2 = _interopRequireDefault(_legendSymbols);\n\nvar _legendTitle = require('./guides/legend-title');\n\nvar _legendTitle2 = _interopRequireDefault(_legendTitle);\n\nvar _guideGroup = require('./guides/guide-group');\n\nvar _guideGroup2 = _interopRequireDefault(_guideGroup);\n\nvar _mark = require('./mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _roles = require('./marks/roles');\n\nvar _encodeUtil = require('./encode/encode-util');\n\nvar _constants = require('./guides/constants');\n\nvar _util = require('../util');\n\nvar _transforms = require('../transforms');\n\nvar _vegaUtil = require('vega-util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction sizeExpression(spec, scope, marks) {\n  var fontSize = getValue(scope, marks[1].encode, 'fontSize', _constants.GuideLabelStyle);\n  if (spec.size) {\n    return { $expr: 'Math.max(Math.ceil(Math.sqrt(_.scale(datum))),' + fontSize + ')' };\n  } else {\n    var symbolSize = getValue(scope, marks[0].encode, 'size');\n    return Math.max(Math.ceil(Math.sqrt(symbolSize)), fontSize);\n  }\n}\n\nfunction legendEnter(config) {\n  var enter = {},\n      count = (0, _encodeUtil.addEncode)(enter, 'fill', config.fillColor) + (0, _encodeUtil.addEncode)(enter, 'stroke', config.strokeColor) + (0, _encodeUtil.addEncode)(enter, 'strokeWidth', config.strokeWidth) + (0, _encodeUtil.addEncode)(enter, 'strokeDash', config.strokeDash) + (0, _encodeUtil.addEncode)(enter, 'cornerRadius', config.cornerRadius);\n  return count ? enter : undefined;\n}\n\nfunction getValue(scope, encode, name, style) {\n  var v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);\n  return +(v ? v.value // TODO support signal?\n  : style && (v = scope.config.style[style]) && v[name]);\n}"},"hash":"754bad996999186d381bbaa06aaa9262","cacheData":{"env":{}}}