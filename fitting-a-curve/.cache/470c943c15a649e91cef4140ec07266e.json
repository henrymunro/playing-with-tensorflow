{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-parser/package.json","includedInParent":true,"mtime":1520359126000},{"name":"./DataScope","loc":{"line":1,"column":22}},{"name":"./util","loc":{"line":5,"column":7}},{"name":"./parsers/expression","loc":{"line":6,"column":28}},{"name":"./transforms","loc":{"line":7,"column":67}},{"name":"vega-util","loc":{"line":8,"column":83}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Scope;\n\nvar _DataScope = require('./DataScope');\n\nvar _DataScope2 = _interopRequireDefault(_DataScope);\n\nvar _util = require('./util');\n\nvar _expression = require('./parsers/expression');\n\nvar _expression2 = _interopRequireDefault(_expression);\n\nvar _transforms = require('./transforms');\n\nvar _vegaUtil = require('vega-util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction Scope(config) {\n  this.config = config;\n\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.background = null;\n  this.eventConfig = null;\n\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\n\nfunction Subscope(scope) {\n  this.config = scope.config;\n\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\n\nvar prototype = Scope.prototype = Subscope.prototype;\n\n// ----\n\nprototype.fork = function () {\n  return new Subscope(this);\n};\n\nprototype.toRuntime = function () {\n  this.finish();\n  return {\n    background: this.background,\n    operators: this.operators,\n    streams: this.streams,\n    updates: this.updates,\n    bindings: this.bindings,\n    eventConfig: this.eventConfig\n  };\n};\n\nprototype.id = function () {\n  return (this._subid ? this._subid + ':' : 0) + this._id++;\n};\n\nprototype.add = function (op) {\n  this.operators.push(op);\n  op.id = this.id();\n  // if pre-registration references exist, resolve them now\n  if (op.refs) {\n    op.refs.forEach(function (ref) {\n      ref.$ref = op.id;\n    });\n    op.refs = null;\n  }\n  return op;\n};\n\nprototype.proxy = function (op) {\n  var vref = op instanceof _util.Entry ? (0, _util.ref)(op) : op;\n  return this.add((0, _transforms.Proxy)({ value: vref }));\n};\n\nprototype.addStream = function (stream) {\n  this.streams.push(stream);\n  stream.id = this.id();\n  return stream;\n};\n\nprototype.addUpdate = function (update) {\n  this.updates.push(update);\n  return update;\n};\n\n// Apply metadata\nprototype.finish = function () {\n  var name, ds;\n\n  // annotate root\n  if (this.root) this.root.root = true;\n\n  // annotate signals\n  for (name in this.signals) {\n    this.signals[name].signal = name;\n  }\n\n  // annotate scales\n  for (name in this.scales) {\n    this.scales[name].scale = name;\n  }\n\n  // annotate data sets\n  function annotate(op, name, type) {\n    var data, list;\n    if (op) {\n      data = op.data || (op.data = {});\n      list = data[name] || (data[name] = []);\n      list.push(type);\n    }\n  }\n  for (name in this.data) {\n    ds = this.data[name];\n    annotate(ds.input, name, 'input');\n    annotate(ds.output, name, 'output');\n    annotate(ds.values, name, 'values');\n    for (var field in ds.index) {\n      annotate(ds.index[field], name, 'index:' + field);\n    }\n  }\n\n  return this;\n};\n\n// ----\n\nprototype.pushState = function (encode, parent, lookup) {\n  this._encode.push((0, _util.ref)(this.add((0, _transforms.Sieve)({ pulse: encode }))));\n  this._parent.push(parent);\n  this._lookup.push(lookup ? (0, _util.ref)(this.proxy(lookup)) : null);\n  this._markpath.push(-1);\n};\n\nprototype.popState = function () {\n  this._encode.pop();\n  this._parent.pop();\n  this._lookup.pop();\n  this._markpath.pop();\n};\n\nprototype.parent = function () {\n  return (0, _vegaUtil.peek)(this._parent);\n};\n\nprototype.encode = function () {\n  return (0, _vegaUtil.peek)(this._encode);\n};\n\nprototype.lookup = function () {\n  return (0, _vegaUtil.peek)(this._lookup);\n};\n\nprototype.markpath = function () {\n  var p = this._markpath;\n  return ++p[p.length - 1];\n};\n\n// ----\n\nprototype.fieldRef = function (field, name) {\n  if ((0, _vegaUtil.isString)(field)) return (0, _util.fieldRef)(field, name);\n  if (!field.signal) {\n    (0, _vegaUtil.error)('Unsupported field reference: ' + (0, _vegaUtil.stringValue)(field));\n  }\n\n  var s = field.signal,\n      f = this.field[s],\n      params;\n\n  if (!f) {\n    // TODO: replace with update signalRef?\n    params = { name: this.signalRef(s) };\n    if (name) params.as = name;\n    this.field[s] = f = (0, _util.ref)(this.add((0, _transforms.Field)(params)));\n  }\n  return f;\n};\n\nprototype.compareRef = function (cmp, stable) {\n  function check(_) {\n    if ((0, _util.isSignal)(_)) {\n      signal = true;\n      return (0, _util.ref)(sig[_.signal]);\n    } else {\n      return _;\n    }\n  }\n\n  var sig = this.signals,\n      signal = false,\n      fields = (0, _vegaUtil.array)(cmp.field).map(check),\n      orders = (0, _vegaUtil.array)(cmp.order).map(check);\n\n  if (stable) {\n    fields.push(_util.tupleidRef);\n  }\n\n  return signal ? (0, _util.ref)(this.add((0, _transforms.Compare)({ fields: fields, orders: orders }))) : (0, _util.compareRef)(fields, orders);\n};\n\nprototype.keyRef = function (fields, flat) {\n  function check(_) {\n    if ((0, _util.isSignal)(_)) {\n      signal = true;\n      return (0, _util.ref)(sig[_.signal]);\n    } else {\n      return _;\n    }\n  }\n\n  var sig = this.signals,\n      signal = false;\n  fields = (0, _vegaUtil.array)(fields).map(check);\n\n  return signal ? (0, _util.ref)(this.add((0, _transforms.Key)({ fields: fields, flat: flat }))) : (0, _util.keyRef)(fields, flat);\n};\n\nprototype.sortRef = function (sort) {\n  if (!sort) return sort;\n\n  // including id ensures stable sorting\n  var a = [(0, _util.aggrField)(sort.op, sort.field), _util.tupleidRef],\n      o = sort.order || _util.Ascending;\n\n  return o.signal ? (0, _util.ref)(this.add((0, _transforms.Compare)({\n    fields: a,\n    orders: [o = this.signalRef(o.signal), o]\n  }))) : (0, _util.compareRef)(a, [o, o]);\n};\n\n// ----\n\nprototype.event = function (source, type) {\n  var key = source + ':' + type;\n  if (!this.events[key]) {\n    var id = this.id();\n    this.streams.push({\n      id: id,\n      source: source,\n      type: type\n    });\n    this.events[key] = id;\n  }\n  return this.events[key];\n};\n\n// ----\n\nprototype.addSignal = function (name, value) {\n  if (this.signals.hasOwnProperty(name)) {\n    (0, _vegaUtil.error)('Duplicate signal name: ' + (0, _vegaUtil.stringValue)(name));\n  }\n  var op = value instanceof _util.Entry ? value : this.add((0, _util.operator)(value));\n  return this.signals[name] = op;\n};\n\nprototype.getSignal = function (name) {\n  if (!this.signals[name]) {\n    (0, _vegaUtil.error)('Unrecognized signal name: ' + (0, _vegaUtil.stringValue)(name));\n  }\n  return this.signals[name];\n};\n\nprototype.signalRef = function (s) {\n  if (this.signals[s]) {\n    return (0, _util.ref)(this.signals[s]);\n  } else if (!this.lambdas.hasOwnProperty(s)) {\n    this.lambdas[s] = this.add((0, _util.operator)(null));\n  }\n  return (0, _util.ref)(this.lambdas[s]);\n};\n\nprototype.parseLambdas = function () {\n  var code = Object.keys(this.lambdas);\n  for (var i = 0, n = code.length; i < n; ++i) {\n    var s = code[i],\n        e = (0, _expression2.default)(s, this),\n        op = this.lambdas[s];\n    op.params = e.$params;\n    op.update = e.$expr;\n  }\n};\n\nprototype.property = function (spec) {\n  return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n};\n\nprototype.objectProperty = function (spec) {\n  return !spec || !(0, _vegaUtil.isObject)(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));\n};\n\nfunction propertyLambda(spec) {\n  return ((0, _vegaUtil.isArray)(spec) ? arrayLambda : objectLambda)(spec);\n}\n\nfunction arrayLambda(array) {\n  var code = '[',\n      i = 0,\n      n = array.length,\n      value;\n\n  for (; i < n; ++i) {\n    value = array[i];\n    code += (i > 0 ? ',' : '') + ((0, _vegaUtil.isObject)(value) ? value.signal || propertyLambda(value) : (0, _vegaUtil.stringValue)(value));\n  }\n  return code + ']';\n}\n\nfunction objectLambda(obj) {\n  var code = '{',\n      i = 0,\n      key,\n      value;\n\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '') + (0, _vegaUtil.stringValue)(key) + ':' + ((0, _vegaUtil.isObject)(value) ? value.signal || propertyLambda(value) : (0, _vegaUtil.stringValue)(value));\n  }\n  return code + '}';\n}\n\nprototype.addBinding = function (name, bind) {\n  if (!this.bindings) {\n    (0, _vegaUtil.error)('Nested signals do not support binding: ' + (0, _vegaUtil.stringValue)(name));\n  }\n  this.bindings.push((0, _vegaUtil.extend)({ signal: name }, bind));\n};\n\n// ----\n\nprototype.addScaleProj = function (name, transform) {\n  if (this.scales.hasOwnProperty(name)) {\n    (0, _vegaUtil.error)('Duplicate scale or projection name: ' + (0, _vegaUtil.stringValue)(name));\n  }\n  this.scales[name] = this.add(transform);\n};\n\nprototype.addScale = function (name, params) {\n  this.addScaleProj(name, (0, _transforms.Scale)(params));\n};\n\nprototype.addProjection = function (name, params) {\n  this.addScaleProj(name, (0, _transforms.Projection)(params));\n};\n\nprototype.getScale = function (name) {\n  if (!this.scales[name]) {\n    (0, _vegaUtil.error)('Unrecognized scale name: ' + (0, _vegaUtil.stringValue)(name));\n  }\n  return this.scales[name];\n};\n\nprototype.projectionRef = prototype.scaleRef = function (name) {\n  return (0, _util.ref)(this.getScale(name));\n};\n\nprototype.projectionType = prototype.scaleType = function (name) {\n  return this.getScale(name).params.type;\n};\n\n// ----\n\nprototype.addData = function (name, dataScope) {\n  if (this.data.hasOwnProperty(name)) {\n    (0, _vegaUtil.error)('Duplicate data set name: ' + (0, _vegaUtil.stringValue)(name));\n  }\n  return this.data[name] = dataScope;\n};\n\nprototype.getData = function (name) {\n  if (!this.data[name]) {\n    (0, _vegaUtil.error)('Undefined data set name: ' + (0, _vegaUtil.stringValue)(name));\n  }\n  return this.data[name];\n};\n\nprototype.addDataPipeline = function (name, entries) {\n  if (this.data.hasOwnProperty(name)) {\n    (0, _vegaUtil.error)('Duplicate data set name: ' + (0, _vegaUtil.stringValue)(name));\n  }\n  return this.addData(name, _DataScope2.default.fromEntries(this, entries));\n};"},"hash":"09f44fbe49bab197c06661523308ad74","cacheData":{"env":{}}}