{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-transforms/package.json","includedInParent":true,"mtime":1520278057000},{"name":"vega-dataflow","loc":{"line":1,"column":24}},{"name":"vega-util","loc":{"line":2,"column":44}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Lookup;\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaUtil = require('vega-util');\n\n/**\n * Extend tuples by joining them with values from a lookup table.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Map} params.index - The lookup table map.\n * @param {Array<function(object): *} params.fields - The fields to lookup.\n * @param {Array<string>} params.as - Output field names for each lookup value.\n * @param {*} [params.default] - A default value to use if lookup fails.\n */\nfunction Lookup(params) {\n  _vegaDataflow.Transform.call(this, {}, params);\n}\n\nLookup.Definition = {\n  \"type\": \"Lookup\",\n  \"metadata\": { \"modifies\": true },\n  \"params\": [{ \"name\": \"index\", \"type\": \"index\", \"params\": [{ \"name\": \"from\", \"type\": \"data\", \"required\": true }, { \"name\": \"key\", \"type\": \"field\", \"required\": true }] }, { \"name\": \"values\", \"type\": \"field\", \"array\": true }, { \"name\": \"fields\", \"type\": \"field\", \"array\": true, \"required\": true }, { \"name\": \"as\", \"type\": \"string\", \"array\": true }, { \"name\": \"default\", \"default\": null }]\n};\n\nvar prototype = (0, _vegaUtil.inherits)(Lookup, _vegaDataflow.Transform);\n\nprototype.transform = function (_, pulse) {\n  var out = pulse,\n      as = _.as,\n      keys = _.fields,\n      index = _.index,\n      values = _.values,\n      defaultValue = _.default == null ? null : _.default,\n      reset = _.modified(),\n      flag = reset ? pulse.SOURCE : pulse.ADD,\n      n = keys.length,\n      set,\n      m,\n      mods;\n\n  if (values) {\n    m = values.length;\n\n    if (n > 1 && !as) {\n      (0, _vegaUtil.error)('Multi-field lookup requires explicit \"as\" parameter.');\n    }\n    if (as && as.length !== n * m) {\n      (0, _vegaUtil.error)('The \"as\" parameter has too few output field names.');\n    }\n    as = as || values.map(_vegaUtil.accessorName);\n\n    set = function (t) {\n      for (var i = 0, k = 0, j, v; i < n; ++i) {\n        v = index.get(keys[i](t));\n        if (v == null) for (j = 0; j < m; ++j, ++k) t[as[k]] = defaultValue;else for (j = 0; j < m; ++j, ++k) t[as[k]] = values[j](v);\n      }\n    };\n  } else {\n    if (!as) {\n      (0, _vegaUtil.error)('Missing output field names.');\n    }\n\n    set = function (t) {\n      for (var i = 0, v; i < n; ++i) {\n        v = index.get(keys[i](t));\n        t[as[i]] = v == null ? defaultValue : v;\n      }\n    };\n  }\n\n  if (reset) {\n    out = pulse.reflow(true);\n  } else {\n    mods = keys.some(function (k) {\n      return pulse.modified(k.fields);\n    });\n    flag |= mods ? pulse.MOD : 0;\n  }\n  pulse.visit(flag, set);\n\n  return out.modifies(as);\n};"},"hash":"43dd15c34b77b93f1648288fcfd01186","cacheData":{"env":{}}}