{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-loader/package.json","includedInParent":true,"mtime":1520276803000},{"name":"./type","loc":{"line":1,"column":38}},{"name":"./formats/index","loc":{"line":2,"column":20}},{"name":"vega-util","loc":{"line":3,"column":20}},{"name":"d3-time-format","loc":{"line":4,"column":34}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (data, schema, dateParse) {\n  schema = schema || {};\n\n  var reader = (0, _index2.default)(schema.type || 'json');\n  if (!reader) (0, _vegaUtil.error)('Unknown data format type: ' + schema.type);\n\n  data = reader(data, schema);\n  if (schema.parse) parse(data, schema.parse, dateParse);\n\n  if (data.hasOwnProperty('columns')) delete data.columns;\n  return data;\n};\n\nvar _type = require('./type');\n\nvar _index = require('./formats/index');\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _vegaUtil = require('vega-util');\n\nvar _d3TimeFormat = require('d3-time-format');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parse(data, types, dateParse) {\n  if (!data.length) return; // early exit for empty data\n\n  dateParse = dateParse || _d3TimeFormat.timeParse;\n\n  var fields = data.columns || Object.keys(data[0]),\n      parsers,\n      datum,\n      field,\n      i,\n      j,\n      n,\n      m;\n\n  if (types === 'auto') types = (0, _type.inferTypes)(data, fields);\n\n  fields = Object.keys(types);\n  parsers = fields.map(function (field) {\n    var type = types[field],\n        parts,\n        pattern;\n\n    if (type && (type.indexOf('date:') === 0 || type.indexOf('utc:') === 0)) {\n      parts = type.split(/:(.+)?/, 2); // split on first :\n      pattern = parts[1];\n\n      if (pattern[0] === '\\'' && pattern[pattern.length - 1] === '\\'' || pattern[0] === '\"' && pattern[pattern.length - 1] === '\"') {\n        pattern = pattern.slice(1, -1);\n      }\n\n      return parts[0] === 'utc' ? (0, _d3TimeFormat.utcParse)(pattern) : dateParse(pattern);\n    }\n\n    if (!_type.typeParsers[type]) {\n      throw Error('Illegal format pattern: ' + field + ':' + type);\n    }\n\n    return _type.typeParsers[type];\n  });\n\n  for (i = 0, n = data.length, m = fields.length; i < n; ++i) {\n    datum = data[i];\n    for (j = 0; j < m; ++j) {\n      field = fields[j];\n      datum[field] = parsers[j](datum[field]);\n    }\n  }\n}"},"hash":"69ff07a28f95228e036e58c417e6cd63","cacheData":{"env":{}}}