{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-hierarchy/package.json","includedInParent":true,"mtime":1518550386000},{"name":"vega-dataflow","loc":{"line":1,"column":41}},{"name":"vega-util","loc":{"line":2,"column":37}},{"name":"d3-collection","loc":{"line":3,"column":19}},{"name":"d3-hierarchy","loc":{"line":4,"column":24}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Nest;\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaUtil = require('vega-util');\n\nvar _d3Collection = require('d3-collection');\n\nvar _d3Hierarchy = require('d3-hierarchy');\n\n/**\n * Nest tuples into a tree structure, grouped by key values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.\n * @param {function(object): *} [params.key] - Unique key field for each tuple.\n *   If not provided, the tuple id field is used.\n * @param {boolean} [params.generate=false] - A boolean flag indicating if\n *   non-leaf nodes generated by this transform should be included in the\n *   output. The default (false) includes only the input data (leaf nodes)\n *   in the data stream.\n */\nfunction Nest(params) {\n  _vegaDataflow.Transform.call(this, null, params);\n}\n\nNest.Definition = {\n  \"type\": \"Nest\",\n  \"metadata\": { \"treesource\": true, \"generates\": true },\n  \"params\": [{ \"name\": \"keys\", \"type\": \"field\", \"array\": true }, { \"name\": \"key\", \"type\": \"field\" }, { \"name\": \"generate\", \"type\": \"boolean\" }]\n};\n\nvar prototype = (0, _vegaUtil.inherits)(Nest, _vegaDataflow.Transform);\n\nfunction children(n) {\n  return n.values;\n}\n\nprototype.transform = function (_, pulse) {\n  if (!pulse.source) {\n    (0, _vegaUtil.error)('Nest transform requires an upstream data source.');\n  }\n\n  var key = _.key || _vegaDataflow.tupleid,\n      gen = _.generate,\n      mod = _.modified(),\n      out = gen || mod ? pulse.fork(pulse.ALL) : pulse,\n      root,\n      tree,\n      map;\n\n  if (!this.value || mod || pulse.changed()) {\n    // collect nodes to remove\n    if (gen && this.value) {\n      out.materialize(out.REM);\n      this.value.each(function (node) {\n        if (node.children) out.rem.push(node);\n      });\n    }\n\n    // generate new tree structure\n    root = (0, _vegaUtil.array)(_.keys).reduce(function (n, k) {\n      n.key(k);return n;\n    }, (0, _d3Collection.nest)()).entries(out.materialize(out.SOURCE).source);\n    this.value = tree = (0, _d3Hierarchy.hierarchy)({ values: root }, children);\n\n    // collect nodes to add\n    if (gen) {\n      out.materialize(out.ADD);\n      out.source = out.source.slice();\n      tree.each(function (node) {\n        if (node.children) {\n          node = (0, _vegaDataflow.ingest)(node.data);\n          out.add.push(node);\n          out.source.push(node);\n        }\n      });\n    }\n\n    // build lookup table\n    map = tree.lookup = {};\n    tree.each(function (node) {\n      if ((0, _vegaDataflow.tupleid)(node.data) != null) {\n        map[key(node.data)] = node;\n      }\n    });\n  }\n\n  out.source.root = this.value;\n  return out;\n};"},"hash":"117a865abd9ce096c0b3070914204b8b","cacheData":{"env":{}}}