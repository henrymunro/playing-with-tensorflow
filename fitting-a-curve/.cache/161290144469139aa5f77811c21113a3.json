{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-encode/package.json","includedInParent":true,"mtime":1520281405000},{"name":"./scale-types","loc":{"line":1,"column":18}},{"name":"vega-scale","loc":{"line":2,"column":40}},{"name":"vega-util","loc":{"line":3,"column":46}},{"name":"d3-format","loc":{"line":7,"column":7}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tickCount = tickCount;\nexports.validTicks = validTicks;\nexports.tickValues = tickValues;\nexports.tickFormat = tickFormat;\n\nvar _scaleTypes = require('./scale-types');\n\nvar _vegaScale = require('vega-scale');\n\nvar _vegaUtil = require('vega-util');\n\nvar _d3Format = require('d3-format');\n\n/**\n * Determine the tick count or interval function.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {*} count - The desired tick count or interval specifier.\n * @return {*} - The tick count or interval function.\n */\nfunction tickCount(scale, count) {\n  var step;\n\n  if ((0, _vegaUtil.isObject)(count)) {\n    step = count.step;\n    count = count.interval;\n  }\n\n  if ((0, _vegaUtil.isString)(count)) {\n    count = scale.type === 'time' ? (0, _vegaScale.timeInterval)(count) : scale.type === 'utc' ? (0, _vegaScale.utcInterval)(count) : (0, _vegaUtil.error)('Only time and utc scales accept interval strings.');\n    if (step) count = count.every(step);\n  }\n\n  return count;\n}\n\n/**\n * Filter a set of candidate tick values, ensuring that only tick values\n * that lie within the scale range are included.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {Array<*>} ticks - The candidate tick values.\n * @param {*} count - The tick count or interval function.\n * @return {Array<*>} - The filtered tick values.\n */\nfunction validTicks(scale, ticks, count) {\n  var range = scale.range(),\n      lo = range[0],\n      hi = (0, _vegaUtil.peek)(range);\n  if (lo > hi) {\n    range = hi;\n    hi = lo;\n    lo = range;\n  }\n\n  ticks = ticks.filter(function (v) {\n    v = scale(v);\n    return !(v < lo || v > hi);\n  });\n\n  if (count > 0 && ticks.length > 1) {\n    var endpoints = [ticks[0], (0, _vegaUtil.peek)(ticks)];\n    while (ticks.length > count && ticks.length >= 3) {\n      ticks = ticks.filter(function (_, i) {\n        return !(i % 2);\n      });\n    }\n    if (ticks.length < 3) {\n      ticks = endpoints;\n    }\n  }\n\n  return ticks;\n}\n\n/**\n * Generate tick values for the given scale and approximate tick count or\n * interval value. If the scale has a 'ticks' method, it will be used to\n * generate the ticks, with the count argument passed as a parameter. If the\n * scale lacks a 'ticks' method, the full scale domain will be returned.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {*} [count] - The approximate number of desired ticks.\n * @return {Array<*>} - The generated tick values.\n */\nfunction tickValues(scale, count) {\n  return scale.ticks ? scale.ticks(count) : scale.domain();\n}\n\n/**\n * Generate a label format function for a scale. If the scale has a\n * 'tickFormat' method, it will be used to generate the formatter, with the\n * count and specifier arguments passed as parameters. If the scale lacks a\n * 'tickFormat' method, the returned formatter performs simple string coercion.\n * If the input scale is a logarithmic scale and the format specifier does not\n * indicate a desired decimal precision, a special variable precision formatter\n * that automatically trims trailing zeroes will be generated.\n * @param {Scale} scale - The scale for which to generate the label formatter.\n * @param {*} [count] - The approximate number of desired ticks.\n * @param {string} [specifier] - The format specifier. Must be a legal d3 4.0\n *   specifier string (see https://github.com/d3/d3-format#formatSpecifier).\n * @return {function(*):string} - The generated label formatter.\n */\nfunction tickFormat(scale, count, specifier) {\n  var format = scale.tickFormat ? scale.tickFormat(count, specifier) : String;\n\n  return scale.type === _scaleTypes.Log ? filter(format, variablePrecision(specifier)) : format;\n}\n\nfunction filter(sourceFormat, targetFormat) {\n  return function (_) {\n    return sourceFormat(_) ? targetFormat(_) : '';\n  };\n}\n\nfunction variablePrecision(specifier) {\n  var s = (0, _d3Format.formatSpecifier)(specifier || ',');\n\n  if (s.precision == null) {\n    s.precision = 12;\n    switch (s.type) {\n      case '%':\n        s.precision -= 2;break;\n      case 'e':\n        s.precision -= 1;break;\n    }\n    return trimZeroes((0, _d3Format.format)(s), // number format\n    (0, _d3Format.format)('.1f')(1)[1] // decimal point character\n    );\n  } else {\n    return (0, _d3Format.format)(s);\n  }\n}\n\nfunction trimZeroes(format, decimalChar) {\n  return function (x) {\n    var str = format(x),\n        dec = str.indexOf(decimalChar),\n        idx,\n        end;\n\n    if (dec < 0) return str;\n\n    idx = rightmostDigit(str, dec);\n    end = idx < str.length ? str.slice(idx) : '';\n    while (--idx > dec) if (str[idx] !== '0') {\n      ++idx;break;\n    }\n\n    return str.slice(0, idx) + end;\n  };\n}\n\nfunction rightmostDigit(str, dec) {\n  var i = str.lastIndexOf('e'),\n      c;\n  if (i > 0) return i;\n  for (i = str.length; --i > dec;) {\n    c = str.charCodeAt(i);\n    if (c >= 48 && c <= 57) return i + 1; // is digit\n  }\n}"},"hash":"060ae64b09e15a584da1835c608bc87a","cacheData":{"env":{}}}