{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-parser/package.json","includedInParent":true,"mtime":1520359126000},{"name":"./expression","loc":{"line":1,"column":28}},{"name":"../util","loc":{"line":2,"column":45}},{"name":"../transforms","loc":{"line":3,"column":21}},{"name":"vega-dataflow","loc":{"line":4,"column":25}},{"name":"vega-util","loc":{"line":5,"column":60}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (spec, scope) {\n  var def = (0, _vegaDataflow.definition)(spec.type);\n  if (!def) (0, _vegaUtil.error)('Unrecognized transform type: ' + (0, _vegaUtil.stringValue)(spec.type));\n\n  var t = (0, _util.entry)(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n\n  return t;\n};\n\nexports.outerExpr = outerExpr;\nexports.outerField = outerField;\nexports.isData = isData;\nexports.isExpr = isExpr;\nexports.isField = isField;\nexports.isCompare = isCompare;\n\nvar _expression = require('./expression');\n\nvar _expression2 = _interopRequireDefault(_expression);\n\nvar _util = require('../util');\n\nvar _transforms = require('../transforms');\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaUtil = require('vega-util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Parse all parameters of a data transform.\n */\nfunction parseParameters(def, spec, scope) {\n  var params = {},\n      pdef,\n      i,\n      n;\n  for (i = 0, n = def.params.length; i < n; ++i) {\n    pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n  return params;\n}\n\n/**\n * Parse a data transform parameter.\n */\n\n\n/**\n * Parse a data transform specification.\n */\nfunction parseParameter(def, spec, scope) {\n  var type = def.type,\n      value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      (0, _vegaUtil.error)('Missing required ' + (0, _vegaUtil.stringValue)(spec.type) + ' parameter: ' + (0, _vegaUtil.stringValue)(def.name));\n    }\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !(0, _util.isSignal)(value) ? value.map(function (v) {\n    return parameterValue(def, v, scope);\n  }) : parameterValue(def, value, scope);\n}\n\n/**\n * Parse a single parameter value.\n */\nfunction parameterValue(def, value, scope) {\n  var type = def.type;\n\n  if ((0, _util.isSignal)(value)) {\n    return isExpr(type) ? (0, _vegaUtil.error)('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);\n  } else {\n    var expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? (0, _expression2.default)(value.expr, scope) : expr && outerField(value) ? (0, _util.fieldRef)(value.field) : isExpr(type) ? (0, _expression2.default)(value, scope) : isData(type) ? (0, _util.ref)(scope.getData(value).values) : isField(type) ? (0, _util.fieldRef)(value) : isCompare(type) ? scope.compareRef(value) : value;\n  }\n}\n\n/**\n * Parse parameter for accessing an index of another data set.\n */\nfunction parseIndexParameter(def, spec, scope) {\n  if (!(0, _vegaUtil.isString)(spec.from)) {\n    (0, _vegaUtil.error)('Lookup \"from\" parameter must be a string literal.');\n  }\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\nfunction parseSubParameters(def, spec, scope) {\n  var value = spec[def.name];\n\n  if (def.array) {\n    if (!(0, _vegaUtil.isArray)(value)) {\n      // signals not allowed!\n      (0, _vegaUtil.error)('Expected an array of sub-parameters. Instead: ' + (0, _vegaUtil.stringValue)(value));\n    }\n    return value.map(function (v) {\n      return parseSubParameter(def, v, scope);\n    });\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n\n/**\n * Parse a sub-parameter object.\n */\nfunction parseSubParameter(def, value, scope) {\n  var params, pdef, k, i, n;\n\n  // loop over defs to find matching key\n  for (i = 0, n = def.params.length; i < n; ++i) {\n    pdef = def.params[i];\n    for (k in pdef.key) {\n      if (pdef.key[k] !== value[k]) {\n        pdef = null;break;\n      }\n    }\n    if (pdef) break;\n  }\n  // raise error if matching key not found\n  if (!pdef) (0, _vegaUtil.error)('Unsupported parameter: ' + (0, _vegaUtil.stringValue)(value));\n\n  // parse params, create Params transform, return ref\n  params = (0, _vegaUtil.extend)(parseParameters(pdef, value, scope), pdef.key);\n  return (0, _util.ref)(scope.add((0, _transforms.Params)(params)));\n}\n\n// -- Utilities -----\n\nfunction outerExpr(_) {\n  return _ && _.expr;\n}\n\nfunction outerField(_) {\n  return _ && _.field;\n}\n\nfunction isData(_) {\n  return _ === 'data';\n}\n\nfunction isExpr(_) {\n  return _ === 'expr';\n}\n\nfunction isField(_) {\n  return _ === 'field';\n}\n\nfunction isCompare(_) {\n  return _ === 'compare';\n}"},"hash":"d13fe70074d2ffd93ce8d0e944b64bfa","cacheData":{"env":{}}}