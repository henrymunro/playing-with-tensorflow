{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-view-transforms/package.json","includedInParent":true,"mtime":1518586109000},{"name":"vega-dataflow","loc":{"line":1,"column":24}},{"name":"vega-scenegraph","loc":{"line":2,"column":31}},{"name":"vega-util","loc":{"line":3,"column":23}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Bound;\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaScenegraph = require('vega-scenegraph');\n\nvar _vegaUtil = require('vega-util');\n\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\nfunction Bound(params) {\n  _vegaDataflow.Transform.call(this, null, params);\n}\n\nvar prototype = (0, _vegaUtil.inherits)(Bound, _vegaDataflow.Transform);\n\nprototype.transform = function (_, pulse) {\n  var view = pulse.dataflow,\n      mark = _.mark,\n      type = mark.marktype,\n      entry = _vegaScenegraph.Marks[type],\n      bound = entry.bound,\n      markBounds = mark.bounds,\n      rebound;\n\n  if (entry.nested) {\n    // multi-item marks have a single bounds instance\n    if (mark.items.length) view.dirty(mark.items[0]);\n    markBounds = boundItem(mark, bound);\n    mark.items.forEach(function (item) {\n      item.bounds.clear().union(markBounds);\n    });\n  } else if (type === 'group' || _.modified()) {\n    // operator parameters modified -> re-bound all items\n    // updates group bounds in response to modified group content\n    pulse.visit(pulse.MOD, function (item) {\n      view.dirty(item);\n    });\n    markBounds.clear();\n    mark.items.forEach(function (item) {\n      markBounds.union(boundItem(item, bound));\n    });\n  } else {\n    // incrementally update bounds, re-bound mark as needed\n    rebound = pulse.changed(pulse.REM);\n\n    pulse.visit(pulse.ADD, function (item) {\n      markBounds.union(boundItem(item, bound));\n    });\n\n    pulse.visit(pulse.MOD, function (item) {\n      rebound = rebound || markBounds.alignsWith(item.bounds);\n      view.dirty(item);\n      markBounds.union(boundItem(item, bound));\n    });\n\n    if (rebound) {\n      markBounds.clear();\n      mark.items.forEach(function (item) {\n        markBounds.union(item.bounds);\n      });\n    }\n  }\n\n  // ensure mark bounds do not exceed any clipping region\n  (0, _vegaScenegraph.boundClip)(mark);\n\n  return pulse.modifies('bounds');\n};\n\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}"},"hash":"f3c9dccbaa206bf45170ee252f189e80","cacheData":{"env":{}}}