{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-parser/package.json","includedInParent":true,"mtime":1520359126000},{"name":"./marks/clip","loc":{"line":1,"column":17}},{"name":"./marks/definition","loc":{"line":2,"column":23}},{"name":"./marks/interactive","loc":{"line":3,"column":24}},{"name":"./marks/data","loc":{"line":4,"column":22}},{"name":"./marks/facet","loc":{"line":5,"column":23}},{"name":"./marks/subflow","loc":{"line":6,"column":25}},{"name":"./marks/role","loc":{"line":7,"column":20}},{"name":"./marks/marktypes","loc":{"line":8,"column":24}},{"name":"./marks/roles","loc":{"line":9,"column":45}},{"name":"./encode/encode-util","loc":{"line":10,"column":23}},{"name":"./transform","loc":{"line":11,"column":27}},{"name":"./trigger","loc":{"line":12,"column":25}},{"name":"./spec","loc":{"line":13,"column":22}},{"name":"../DataScope","loc":{"line":14,"column":22}},{"name":"../util","loc":{"line":15,"column":28}},{"name":"vega-util","loc":{"line":16,"column":20}},{"name":"../transforms","loc":{"line":17,"column":100}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (spec, scope) {\n  var role = (0, _role2.default)(spec),\n      group = spec.type === _marktypes.GroupMark,\n      facet = spec.from && spec.from.facet,\n      layout = spec.layout || role === _roles.ScopeRole || role === _roles.FrameRole,\n      nested = role === _roles.MarkRole || layout || facet,\n      overlap = spec.overlap,\n      ops,\n      op,\n      input,\n      store,\n      bound,\n      render,\n      sieve,\n      name,\n      joinRef,\n      markRef,\n      encodeRef,\n      layoutRef,\n      boundRef;\n\n  // resolve input data\n  input = (0, _data2.default)(spec.from, group, scope);\n\n  // data join to map tuples to visual items\n  op = scope.add((0, _transforms.DataJoin)({\n    key: input.key || (spec.key ? (0, _util.fieldRef)(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  joinRef = (0, _util.ref)(op);\n\n  // collect visual items\n  op = store = scope.add((0, _transforms.Collect)({ pulse: joinRef }));\n\n  // connect visual items to scenegraph\n  op = scope.add((0, _transforms.Mark)({\n    markdef: (0, _definition2.default)(spec),\n    interactive: (0, _interactive2.default)(spec.interactive, scope),\n    clip: (0, _clip2.default)(spec.clip, scope),\n    context: { $context: true },\n    groups: scope.lookup(),\n    parent: scope.signals.parent ? scope.signalRef('parent') : null,\n    index: scope.markpath(),\n    pulse: (0, _util.ref)(op)\n  }));\n  markRef = (0, _util.ref)(op);\n\n  // add visual encoders\n  op = scope.add((0, _transforms.Encode)((0, _encodeUtil.encoders)(spec.encode, spec.type, role, spec.style, scope, { pulse: markRef })));\n\n  // monitor parent marks to propagate changes\n  op.params.parent = scope.encode();\n\n  // add post-encoding transforms, if defined\n  if (spec.transform) {\n    spec.transform.forEach(function (_) {\n      var tx = (0, _transform2.default)(_, scope);\n      if (tx.metadata.generates || tx.metadata.changes) {\n        (0, _vegaUtil.error)('Mark transforms should not generate new data.');\n      }\n      tx.params.pulse = (0, _util.ref)(op);\n      scope.add(op = tx);\n    });\n  }\n\n  // if item sort specified, perform post-encoding\n  if (spec.sort) {\n    op = scope.add((0, _transforms.SortItems)({\n      sort: scope.compareRef(spec.sort, true), // stable sort\n      pulse: (0, _util.ref)(op)\n    }));\n  }\n\n  encodeRef = (0, _util.ref)(op);\n\n  // add view layout operator if needed\n  if (facet || layout) {\n    layout = scope.add((0, _transforms.ViewLayout)({\n      layout: scope.objectProperty(spec.layout),\n      legendMargin: scope.config.legendMargin,\n      mark: markRef,\n      pulse: encodeRef\n    }));\n    layoutRef = (0, _util.ref)(layout);\n  }\n\n  // compute bounding boxes\n  bound = scope.add((0, _transforms.Bound)({ mark: markRef, pulse: layoutRef || encodeRef }));\n  boundRef = (0, _util.ref)(bound);\n\n  // if group mark, recurse to parse nested content\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) {\n      ops = scope.operators;ops.pop();if (layout) ops.pop();\n    }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? (0, _facet2.default)(spec, scope, input) // explicit facet\n    : nested ? (0, _subflow2.default)(spec, scope, input) // standard mark group\n    : (0, _spec2.default)(spec, scope); // guide group, we can avoid nested scopes\n    scope.popState();\n\n    if (nested) {\n      if (layout) ops.push(layout);ops.push(bound);\n    }\n  }\n\n  if (overlap) {\n    op = {\n      method: overlap.method === true ? 'parity' : overlap.method,\n      pulse: boundRef\n    };\n    if (overlap.order) {\n      op.sort = scope.compareRef({ field: overlap.order });\n    }\n    if (overlap.bound) {\n      op.boundScale = scope.scaleRef(overlap.bound.scale);\n      op.boundOrient = overlap.bound.orient;\n      op.boundTolerance = overlap.bound.tolerance;\n    }\n    boundRef = (0, _util.ref)(scope.add((0, _transforms.Overlap)(op)));\n  }\n\n  // render / sieve items\n  render = scope.add((0, _transforms.Render)({ pulse: boundRef }));\n  sieve = scope.add((0, _transforms.Sieve)({ pulse: (0, _util.ref)(render) }, undefined, scope.parent()));\n\n  // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new _DataScope2.default(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(function (on) {\n      if (on.insert || on.remove || on.toggle) {\n        (0, _vegaUtil.error)('Marks only support modify triggers.');\n      }\n      (0, _trigger2.default)(on, scope, name);\n    });\n  }\n};\n\nvar _clip = require('./marks/clip');\n\nvar _clip2 = _interopRequireDefault(_clip);\n\nvar _definition = require('./marks/definition');\n\nvar _definition2 = _interopRequireDefault(_definition);\n\nvar _interactive = require('./marks/interactive');\n\nvar _interactive2 = _interopRequireDefault(_interactive);\n\nvar _data = require('./marks/data');\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _facet = require('./marks/facet');\n\nvar _facet2 = _interopRequireDefault(_facet);\n\nvar _subflow = require('./marks/subflow');\n\nvar _subflow2 = _interopRequireDefault(_subflow);\n\nvar _role = require('./marks/role');\n\nvar _role2 = _interopRequireDefault(_role);\n\nvar _marktypes = require('./marks/marktypes');\n\nvar _roles = require('./marks/roles');\n\nvar _encodeUtil = require('./encode/encode-util');\n\nvar _transform = require('./transform');\n\nvar _transform2 = _interopRequireDefault(_transform);\n\nvar _trigger = require('./trigger');\n\nvar _trigger2 = _interopRequireDefault(_trigger);\n\nvar _spec = require('./spec');\n\nvar _spec2 = _interopRequireDefault(_spec);\n\nvar _DataScope = require('../DataScope');\n\nvar _DataScope2 = _interopRequireDefault(_DataScope);\n\nvar _util = require('../util');\n\nvar _vegaUtil = require('vega-util');\n\nvar _transforms = require('../transforms');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }"},"hash":"ff0faff65ff7345d0e24cc336bfe06a5","cacheData":{"env":{}}}