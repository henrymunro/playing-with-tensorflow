{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-runtime/package.json","includedInParent":true,"mtime":1508906165000},{"name":"./dataflow","loc":{"line":1,"column":26}},{"name":"./expression","loc":{"line":2,"column":52}},{"name":"vega-dataflow","loc":{"line":3,"column":22}},{"name":"vega-util","loc":{"line":4,"column":77}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseParameters;\n\nvar _dataflow = require('./dataflow');\n\nvar _dataflow2 = _interopRequireDefault(_dataflow);\n\nvar _expression = require('./expression');\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaUtil = require('vega-util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Parse a set of operator parameters.\n */\nfunction parseParameters(spec, ctx, params) {\n  params = params || {};\n  var key, value;\n\n  for (key in spec) {\n    value = spec[key];\n\n    if (value && value.$expr && value.$params) {\n      // if expression, parse its parameters\n      parseParameters(value.$params, ctx, params);\n    }\n\n    params[key] = (0, _vegaUtil.isArray)(value) ? value.map(function (v) {\n      return parseParameter(v, ctx);\n    }) : parseParameter(value, ctx);\n  }\n  return params;\n}\n\n/**\n * Parse a single parameter.\n */\nfunction parseParameter(spec, ctx) {\n  if (!spec || !(0, _vegaUtil.isObject)(spec)) return spec;\n\n  for (var i = 0, n = PARSERS.length, p; i < n; ++i) {\n    p = PARSERS[i];\n    if (spec.hasOwnProperty(p.key)) {\n      return p.parse(spec, ctx);\n    }\n  }\n  return spec;\n}\n\n/** Reference parsers. */\nvar PARSERS = [{ key: '$ref', parse: getOperator }, { key: '$key', parse: getKey }, { key: '$expr', parse: getExpression }, { key: '$field', parse: getField }, { key: '$encode', parse: getEncode }, { key: '$compare', parse: getCompare }, { key: '$context', parse: getContext }, { key: '$subflow', parse: getSubflow }, { key: '$tupleid', parse: getTupleId }];\n\n/**\n * Resolve an operator reference.\n */\nfunction getOperator(_, ctx) {\n  return ctx.get(_.$ref) || (0, _vegaUtil.error)('Operator not defined: ' + _.$ref);\n}\n\n/**\n * Resolve an expression reference.\n */\nfunction getExpression(_, ctx) {\n  var k = 'e:' + _.$expr;\n  return ctx.fn[k] || (ctx.fn[k] = (0, _vegaUtil.accessor)((0, _expression.parameterExpression)(_.$expr, ctx), _.$fields, _.$name));\n}\n\n/**\n * Resolve a key accessor reference.\n */\nfunction getKey(_, ctx) {\n  var k = 'k:' + _.$key + '_' + !!_.$flat;\n  return ctx.fn[k] || (ctx.fn[k] = (0, _vegaUtil.key)(_.$key, _.$flat));\n}\n\n/**\n * Resolve a field accessor reference.\n */\nfunction getField(_, ctx) {\n  if (!_.$field) return null;\n  var k = 'f:' + _.$field + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = (0, _vegaUtil.field)(_.$field, _.$name));\n}\n\n/**\n * Resolve a comparator function reference.\n */\nfunction getCompare(_, ctx) {\n  var k = 'c:' + _.$compare + '_' + _.$order,\n      c = (0, _vegaUtil.array)(_.$compare).map(function (_) {\n    return _ && _.$tupleid ? _vegaDataflow.tupleid : _;\n  });\n  return ctx.fn[k] || (ctx.fn[k] = (0, _vegaUtil.compare)(c, _.$order));\n}\n\n/**\n * Resolve an encode operator reference.\n */\nfunction getEncode(_, ctx) {\n  var spec = _.$encode,\n      encode = {},\n      name,\n      enc;\n\n  for (name in spec) {\n    enc = spec[name];\n    encode[name] = (0, _vegaUtil.accessor)((0, _expression.encodeExpression)(enc.$expr, ctx), enc.$fields);\n    encode[name].output = enc.$output;\n  }\n  return encode;\n}\n\n/**\n * Resolve an context reference.\n */\nfunction getContext(_, ctx) {\n  return ctx;\n}\n\n/**\n * Resolve a recursive subflow specification.\n */\nfunction getSubflow(_, ctx) {\n  var spec = _.$subflow;\n  return function (dataflow, key, parent) {\n    var subctx = (0, _dataflow2.default)(spec, ctx.fork()),\n        op = subctx.get(spec.operators[0].id),\n        p = subctx.signals.parent;\n    if (p) p.set(parent);\n    return op;\n  };\n}\n\n/**\n * Resolve a tuple id reference.\n */\nfunction getTupleId() {\n  return _vegaDataflow.tupleid;\n}"},"hash":"5a421c563c7f928c5ed2b1fe75fc3df9","cacheData":{"env":{}}}