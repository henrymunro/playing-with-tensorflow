{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-transforms/package.json","includedInParent":true,"mtime":1520278057000},{"name":"vega-dataflow","loc":{"line":1,"column":32}},{"name":"vega-util","loc":{"line":2,"column":23}},{"name":"process"}],"generated":{"js":"var process = require(\"process\");\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = CountPattern;\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaUtil = require('vega-util');\n\n/**\n * Count regexp-defined pattern occurrences in a text field.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - An accessor for the text field.\n * @param {string} [params.pattern] - RegExp string defining the text pattern.\n * @param {string} [params.case] - One of 'lower', 'upper' or null (mixed) case.\n * @param {string} [params.stopwords] - RegExp string of words to ignore.\n */\nfunction CountPattern(params) {\n  _vegaDataflow.Transform.call(this, null, params);\n}\n\nCountPattern.Definition = {\n  \"type\": \"CountPattern\",\n  \"metadata\": { \"generates\": true, \"changes\": true },\n  \"params\": [{ \"name\": \"field\", \"type\": \"field\", \"required\": true }, { \"name\": \"case\", \"type\": \"enum\", \"values\": [\"upper\", \"lower\", \"mixed\"], \"default\": \"mixed\" }, { \"name\": \"pattern\", \"type\": \"string\", \"default\": \"[\\\\w\\\"]+\" }, { \"name\": \"stopwords\", \"type\": \"string\", \"default\": \"\" }, { \"name\": \"as\", \"type\": \"string\", \"array\": true, \"length\": 2, \"default\": [\"text\", \"count\"] }]\n};\n\nfunction tokenize(text, tcase, match) {\n  switch (tcase) {\n    case 'upper':\n      text = text.toUpperCase();break;\n    case 'lower':\n      text = text.toLowerCase();break;\n  }\n  return text.match(match);\n}\n\nvar prototype = (0, _vegaUtil.inherits)(CountPattern, _vegaDataflow.Transform);\n\nprototype.transform = function (_, pulse) {\n  function process(update) {\n    return function (tuple) {\n      var tokens = tokenize(get(tuple), _.case, match) || [],\n          t;\n      for (var i = 0, n = tokens.length; i < n; ++i) {\n        if (!stop.test(t = tokens[i])) update(t);\n      }\n    };\n  }\n\n  var init = this._parameterCheck(_, pulse),\n      counts = this._counts,\n      match = this._match,\n      stop = this._stop,\n      get = _.field,\n      as = _.as || ['text', 'count'],\n      add = process(function (t) {\n    counts[t] = 1 + (counts[t] || 0);\n  }),\n      rem = process(function (t) {\n    counts[t] -= 1;\n  });\n\n  if (init) {\n    pulse.visit(pulse.SOURCE, add);\n  } else {\n    pulse.visit(pulse.ADD, add);\n    pulse.visit(pulse.REM, rem);\n  }\n\n  return this._finish(pulse, as); // generate output tuples\n};\n\nprototype._parameterCheck = function (_, pulse) {\n  var init = false;\n\n  if (_.modified('stopwords') || !this._stop) {\n    this._stop = new RegExp('^' + (_.stopwords || '') + '$', 'i');\n    init = true;\n  }\n\n  if (_.modified('pattern') || !this._match) {\n    this._match = new RegExp(_.pattern || '[\\\\w\\']+', 'g');\n    init = true;\n  }\n\n  if (_.modified('field') || pulse.modified(_.field.fields)) {\n    init = true;\n  }\n\n  if (init) this._counts = {};\n  return init;\n};\n\nprototype._finish = function (pulse, as) {\n  var counts = this._counts,\n      tuples = this._tuples || (this._tuples = {}),\n      text = as[0],\n      count = as[1],\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      w,\n      t,\n      c;\n\n  for (w in counts) {\n    t = tuples[w];\n    c = counts[w] || 0;\n    if (!t && c) {\n      tuples[w] = t = (0, _vegaDataflow.ingest)({});\n      t[text] = w;\n      t[count] = c;\n      out.add.push(t);\n    } else if (c === 0) {\n      if (t) out.rem.push(t);\n      counts[w] = null;\n      tuples[w] = null;\n    } else if (t[count] !== c) {\n      t[count] = c;\n      out.mod.push(t);\n    }\n  }\n\n  return out.modifies(as);\n};"},"hash":"d6075afe1c809f145c20420bb9a379f4","cacheData":{"env":{}}}