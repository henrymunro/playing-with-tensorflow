{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-scenegraph/package.json","includedInParent":true,"mtime":1518728314000},{"name":"./Renderer","loc":{"line":1,"column":21}},{"name":"./Bounds","loc":{"line":2,"column":19}},{"name":"./marks/index","loc":{"line":3,"column":18}},{"name":"./util/dom","loc":{"line":5,"column":23}},{"name":"./util/canvas/clip","loc":{"line":6,"column":17}},{"name":"./util/canvas/resize","loc":{"line":7,"column":19}},{"name":"vega-canvas","loc":{"line":8,"column":21}},{"name":"vega-util","loc":{"line":9,"column":23}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = CanvasRenderer;\n\nvar _Renderer = require('./Renderer');\n\nvar _Renderer2 = _interopRequireDefault(_Renderer);\n\nvar _Bounds = require('./Bounds');\n\nvar _Bounds2 = _interopRequireDefault(_Bounds);\n\nvar _index = require('./marks/index');\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _dom = require('./util/dom');\n\nvar _clip = require('./util/canvas/clip');\n\nvar _clip2 = _interopRequireDefault(_clip);\n\nvar _resize = require('./util/canvas/resize');\n\nvar _resize2 = _interopRequireDefault(_resize);\n\nvar _vegaCanvas = require('vega-canvas');\n\nvar _vegaUtil = require('vega-util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction CanvasRenderer(loader) {\n  _Renderer2.default.call(this, loader);\n  this._redraw = false;\n  this._dirty = new _Bounds2.default();\n}\n\nvar prototype = (0, _vegaUtil.inherits)(CanvasRenderer, _Renderer2.default),\n    base = _Renderer2.default.prototype,\n    tempBounds = new _Bounds2.default();\n\nprototype.initialize = function (el, width, height, origin, scaleFactor) {\n  this._canvas = (0, _vegaCanvas.canvas)(1, 1); // instantiate a small canvas\n  if (el) {\n    (0, _dom.domClear)(el, 0).appendChild(this._canvas);\n    this._canvas.setAttribute('class', 'marks');\n  }\n  // this method will invoke resize to size the canvas appropriately\n  return base.initialize.call(this, el, width, height, origin, scaleFactor);\n};\n\nprototype.resize = function (width, height, origin, scaleFactor) {\n  base.resize.call(this, width, height, origin, scaleFactor);\n  (0, _resize2.default)(this._canvas, this._width, this._height, this._origin, this._scale);\n  this._redraw = true;\n  return this;\n};\n\nprototype.canvas = function () {\n  return this._canvas;\n};\n\nprototype.context = function () {\n  return this._canvas ? this._canvas.getContext('2d') : null;\n};\n\nprototype.dirty = function (item) {\n  var b = translate(item.bounds, item.mark.group);\n  this._dirty.union(b);\n};\n\nfunction clipToBounds(g, b, origin) {\n  // expand bounds by 1 pixel, then round to pixel boundaries\n  b.expand(1).round();\n\n  // to avoid artifacts translate if origin has fractional pixels\n  b.translate(-(origin[0] % 1), -(origin[1] % 1));\n\n  // set clipping path\n  g.beginPath();\n  g.rect(b.x1, b.y1, b.width(), b.height());\n  g.clip();\n\n  return b;\n}\n\nfunction translate(bounds, group) {\n  if (group == null) return bounds;\n  var b = tempBounds.clear().union(bounds);\n  for (; group != null; group = group.mark.group) {\n    b.translate(group.x || 0, group.y || 0);\n  }\n  return b;\n}\n\nprototype._render = function (scene) {\n  var g = this.context(),\n      o = this._origin,\n      w = this._width,\n      h = this._height,\n      b = this._dirty;\n\n  // setup\n  g.save();\n  if (this._redraw || b.empty()) {\n    this._redraw = false;\n    b = null;\n  } else {\n    b = clipToBounds(g, b, o);\n  }\n\n  this.clear(-o[0], -o[1], w, h);\n\n  // render\n  this.draw(g, scene, b);\n\n  // takedown\n  g.restore();\n\n  this._dirty.clear();\n  return this;\n};\n\nprototype.draw = function (ctx, scene, bounds) {\n  var mark = _index2.default[scene.marktype];\n  if (scene.clip) (0, _clip2.default)(ctx, scene);\n  mark.draw.call(this, ctx, scene, bounds);\n  if (scene.clip) ctx.restore();\n};\n\nprototype.clear = function (x, y, w, h) {\n  var g = this.context();\n  g.clearRect(x, y, w, h);\n  if (this._bgcolor != null) {\n    g.fillStyle = this._bgcolor;\n    g.fillRect(x, y, w, h);\n  }\n};"},"hash":"7718c1fb1eeded863175e7d6a10120c5","cacheData":{"env":{}}}