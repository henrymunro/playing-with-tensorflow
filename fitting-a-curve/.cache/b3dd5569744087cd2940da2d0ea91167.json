{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-dataflow/package.json","includedInParent":true,"mtime":1518291445000},{"name":"./Pulse","loc":{"line":1,"column":18}},{"name":"vega-util","loc":{"line":2,"column":39}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = MultiPulse;\n\nvar _Pulse = require('./Pulse');\n\nvar _Pulse2 = _interopRequireDefault(_Pulse);\n\nvar _vegaUtil = require('vega-util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Represents a set of multiple pulses. Used as input for operators\n * that accept multiple pulses at a time. Contained pulses are\n * accessible via the public \"pulses\" array property. This pulse doe\n * not carry added, removed or modified tuples directly. However,\n * the visit method can be used to traverse all such tuples contained\n * in sub-pulses with a timestamp matching this parent multi-pulse.\n * @constructor\n * @param {Dataflow} dataflow - The backing dataflow instance.\n * @param {number} stamp - The timestamp.\n * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.\n */\nfunction MultiPulse(dataflow, stamp, pulses, encode) {\n  var p = this,\n      c = 0,\n      pulse,\n      hash,\n      i,\n      n,\n      f;\n\n  this.dataflow = dataflow;\n  this.stamp = stamp;\n  this.fields = null;\n  this.encode = encode || null;\n  this.pulses = pulses;\n\n  for (i = 0, n = pulses.length; i < n; ++i) {\n    pulse = pulses[i];\n    if (pulse.stamp !== stamp) continue;\n\n    if (pulse.fields) {\n      hash = p.fields || (p.fields = {});\n      for (f in pulse.fields) {\n        hash[f] = 1;\n      }\n    }\n\n    if (pulse.changed(p.ADD)) c |= p.ADD;\n    if (pulse.changed(p.REM)) c |= p.REM;\n    if (pulse.changed(p.MOD)) c |= p.MOD;\n  }\n\n  this.changes = c;\n}\n\nvar prototype = (0, _vegaUtil.inherits)(MultiPulse, _Pulse2.default);\n\n/**\n * Creates a new pulse based on the values of this pulse.\n * The dataflow, time stamp and field modification values are copied over.\n * @return {Pulse}\n */\nprototype.fork = function (flags) {\n  var p = new _Pulse2.default(this.dataflow).init(this, flags & this.NO_FIELDS);\n  if (flags !== undefined) {\n    if (flags & p.ADD) {\n      this.visit(p.ADD, function (t) {\n        return p.add.push(t);\n      });\n    }\n    if (flags & p.REM) {\n      this.visit(p.REM, function (t) {\n        return p.rem.push(t);\n      });\n    }\n    if (flags & p.MOD) {\n      this.visit(p.MOD, function (t) {\n        return p.mod.push(t);\n      });\n    }\n  }\n  return p;\n};\n\nprototype.changed = function (flags) {\n  return this.changes & flags;\n};\n\nprototype.modified = function (_) {\n  var p = this,\n      fields = p.fields;\n  return !(fields && p.changes & p.MOD) ? 0 : (0, _vegaUtil.isArray)(_) ? _.some(function (f) {\n    return fields[f];\n  }) : fields[_];\n};\n\nprototype.filter = function () {\n  (0, _vegaUtil.error)('MultiPulse does not support filtering.');\n};\n\nprototype.materialize = function () {\n  (0, _vegaUtil.error)('MultiPulse does not support materialization.');\n};\n\nprototype.visit = function (flags, visitor) {\n  var p = this,\n      pulses = p.pulses,\n      n = pulses.length,\n      i = 0;\n\n  if (flags & p.SOURCE) {\n    for (; i < n; ++i) {\n      pulses[i].visit(flags, visitor);\n    }\n  } else {\n    for (; i < n; ++i) {\n      if (pulses[i].stamp === p.stamp) {\n        pulses[i].visit(flags, visitor);\n      }\n    }\n  }\n\n  return p;\n};"},"hash":"661de9fa6ee67cbb13f543ce99ea8e85","cacheData":{"env":{}}}