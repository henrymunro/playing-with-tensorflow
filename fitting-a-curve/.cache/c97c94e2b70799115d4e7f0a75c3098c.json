{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-transforms/package.json","includedInParent":true,"mtime":1520278057000},{"name":"./util/AggregateKeys","loc":{"line":1,"column":23}},{"name":"./util/AggregateOps","loc":{"line":2,"column":32}},{"name":"./util/SortedList","loc":{"line":3,"column":23}},{"name":"./util/WindowOps","loc":{"line":4,"column":29}},{"name":"./util/WindowState","loc":{"line":5,"column":24}},{"name":"vega-dataflow","loc":{"line":6,"column":33}},{"name":"vega-util","loc":{"line":7,"column":33}},{"name":"d3-array","loc":{"line":8,"column":23}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Window;\n\nvar _AggregateKeys = require('./util/AggregateKeys');\n\nvar _AggregateOps = require('./util/AggregateOps');\n\nvar _SortedList = require('./util/SortedList');\n\nvar _SortedList2 = _interopRequireDefault(_SortedList);\n\nvar _WindowOps = require('./util/WindowOps');\n\nvar _WindowState = require('./util/WindowState');\n\nvar _WindowState2 = _interopRequireDefault(_WindowState);\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaUtil = require('vega-util');\n\nvar _d3Array = require('d3-array');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Perform window calculations and write results to the input stream.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator function for sorting tuples within a window.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors by which to partition tuples into separate windows.\n * @param {Array<string>} params.ops - An array of strings indicating window operations to perform.\n * @param {Array<function(object): *>} [params.fields] - An array of accessors\n *   for data fields to use as inputs to window operations.\n * @param {Array<*>} [params.params] - An array of parameter values for window operations.\n * @param {Array<string>} [params.as] - An array of output field names for window operations.\n * @param {Array<number>} [params.frame] - Window frame definition as two-element array.\n * @param {boolean} [params.ignorePeers=false] - If true, base window frame boundaries on row\n *   number alone, ignoring peers with identical sort values. If false (default),\n *   the window boundaries will be adjusted to include peer values.\n */\nfunction Window(params) {\n  _vegaDataflow.Transform.call(this, {}, params);\n  this._mlen = 0;\n  this._mods = [];\n}\n\nWindow.Definition = {\n  \"type\": \"Window\",\n  \"metadata\": { \"modifies\": true },\n  \"params\": [{ \"name\": \"sort\", \"type\": \"compare\" }, { \"name\": \"groupby\", \"type\": \"field\", \"array\": true }, { \"name\": \"ops\", \"type\": \"enum\", \"array\": true, \"values\": _WindowOps.ValidWindowOps.concat(_AggregateOps.ValidAggregateOps) }, { \"name\": \"params\", \"type\": \"number\", \"null\": true, \"array\": true }, { \"name\": \"fields\", \"type\": \"field\", \"null\": true, \"array\": true }, { \"name\": \"as\", \"type\": \"string\", \"null\": true, \"array\": true }, { \"name\": \"frame\", \"type\": \"number\", \"null\": true, \"array\": true, \"length\": 2, \"default\": [null, 0] }, { \"name\": \"ignorePeers\", \"type\": \"boolean\", \"default\": false }]\n};\n\nvar prototype = (0, _vegaUtil.inherits)(Window, _vegaDataflow.Transform);\n\nprototype.transform = function (_, pulse) {\n  var self = this,\n      state = self.state,\n      mod = _.modified(),\n      i,\n      n;\n\n  this.stamp = pulse.stamp;\n\n  // initialize window state\n  if (!state || mod) {\n    state = self.state = new _WindowState2.default(_);\n  }\n\n  // retrieve group for a tuple\n  var key = (0, _AggregateKeys.groupkey)(_.groupby);\n  function group(t) {\n    return self.group(key(t));\n  }\n\n  // partition input tuples\n  if (mod || pulse.modified(state.inputs)) {\n    self.value = {};\n    pulse.visit(pulse.SOURCE, function (t) {\n      group(t).add(t);\n    });\n  } else {\n    pulse.visit(pulse.REM, function (t) {\n      group(t).remove(t);\n    });\n    pulse.visit(pulse.ADD, function (t) {\n      group(t).add(t);\n    });\n  }\n\n  // perform window calculations for each modified partition\n  for (i = 0, n = self._mlen; i < n; ++i) {\n    processPartition(self._mods[i], state, _);\n  }\n  self._mlen = 0;\n  self._mods = [];\n\n  // TODO don't reflow everything?\n  return pulse.reflow(mod).modifies(state.outputs);\n};\n\nprototype.group = function (key) {\n  var self = this,\n      group = self.value[key];\n\n  if (!group) {\n    group = self.value[key] = (0, _SortedList2.default)(_vegaDataflow.tupleid);\n    group.stamp = -1;\n  }\n\n  if (group.stamp < self.stamp) {\n    group.stamp = self.stamp;\n    self._mods[self._mlen++] = group;\n  }\n\n  return group;\n};\n\nfunction processPartition(list, state, _) {\n  var sort = _.sort,\n      range = sort && !_.ignorePeers,\n      frame = _.frame || [null, 0],\n      data = list.data(sort),\n      n = data.length,\n      i = 0,\n      b = range ? (0, _d3Array.bisector)(sort) : null,\n      w = {\n    i0: 0, i1: 0, p0: 0, p1: 0, index: 0,\n    data: data, compare: sort || (0, _vegaUtil.constant)(-1)\n  };\n\n  for (state.init(); i < n; ++i) {\n    setWindow(w, frame, i, n);\n    if (range) adjustRange(w, b);\n    state.update(w, data[i]);\n  }\n}\n\nfunction setWindow(w, f, i, n) {\n  w.p0 = w.i0;\n  w.p1 = w.i1;\n  w.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));\n  w.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);\n  w.index = i;\n}\n\n// if frame type is 'range', adjust window for peer values\nfunction adjustRange(w, bisect) {\n  var r0 = w.i0,\n      r1 = w.i1 - 1,\n      c = w.compare,\n      d = w.data,\n      n = d.length - 1;\n\n  if (r0 > 0 && !c(d[r0], d[r0 - 1])) w.i0 = bisect.left(d, d[r0]);\n  if (r1 < n && !c(d[r1], d[r1 + 1])) w.i1 = bisect.right(d, d[r1]);\n}"},"hash":"02d50125d54176ff5529e49a362a2ba8","cacheData":{"env":{}}}