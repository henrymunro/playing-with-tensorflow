{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-parser/package.json","includedInParent":true,"mtime":1520359126000},{"name":"../util","loc":{"line":1,"column":31}},{"name":"../transforms","loc":{"line":2,"column":74}},{"name":"vega-util","loc":{"line":3,"column":77}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isOrdinal = isOrdinal;\nexports.isQuantile = isQuantile;\nexports.initScale = initScale;\nexports.parseScale = parseScale;\n\nvar _util = require('../util');\n\nvar _transforms = require('../transforms');\n\nvar _vegaUtil = require('vega-util');\n\nvar FIELD_REF_ID = 0;\n\nvar types = ['identity', 'ordinal', 'band', 'point', 'bin-linear', 'bin-ordinal', 'linear', 'pow', 'sqrt', 'log', 'sequential', 'time', 'utc', 'quantize', 'quantile', 'threshold'];\n\nvar allTypes = (0, _vegaUtil.toSet)(types),\n    ordinalTypes = (0, _vegaUtil.toSet)(types.slice(1, 6));\n\nfunction isOrdinal(type) {\n  return ordinalTypes.hasOwnProperty(type);\n}\n\nfunction isQuantile(type) {\n  return type === 'quantile';\n}\n\nfunction initScale(spec, scope) {\n  var type = spec.type || 'linear';\n\n  if (!allTypes.hasOwnProperty(type)) {\n    (0, _vegaUtil.error)('Unrecognized scale type: ' + (0, _vegaUtil.stringValue)(type));\n  }\n\n  scope.addScale(spec.name, {\n    type: type,\n    domain: undefined\n  });\n}\n\nfunction parseScale(spec, scope) {\n  var params = scope.getScale(spec.name).params,\n      key;\n\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    parseScaleNice(spec.nice, params);\n  }\n\n  for (key in spec) {\n    if (params.hasOwnProperty(key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !(0, _vegaUtil.isObject)(v) ? v : v.signal ? scope.signalRef(v.signal) : (0, _vegaUtil.error)('Unsupported object: ' + (0, _vegaUtil.stringValue)(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal ? scope.signalRef(v.signal) : v.map(function (v) {\n    return parseLiteral(v, scope);\n  });\n}\n\nfunction dataLookupError(name) {\n  (0, _vegaUtil.error)('Can not find data set: ' + (0, _vegaUtil.stringValue)(name));\n}\n\n// -- SCALE DOMAIN ----\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      (0, _vegaUtil.error)('No scale domain defined for domainMin/domainMax to override.');\n    }\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal) : ((0, _vegaUtil.isArray)(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(function (v) {\n    return parseLiteral(v, scope);\n  });\n}\n\nfunction singularDomain(domain, spec, scope) {\n  var data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n\n  return isOrdinal(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : isQuantile(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  var data = domain.data,\n      fields = domain.fields.reduce(function (dom, d) {\n    d = (0, _vegaUtil.isString)(d) ? { data: data, field: d } : (0, _vegaUtil.isArray)(d) || d.signal ? fieldRef(d, scope) : d;\n    dom.push(d);\n    return dom;\n  }, []);\n\n  return (isOrdinal(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef(data, scope) {\n  var name = '_:vega:_' + FIELD_REF_ID++,\n      coll = (0, _transforms.Collect)({});\n\n  if ((0, _vegaUtil.isArray)(data)) {\n    coll.value = { $ingest: data };\n  } else if (data.signal) {\n    var code = 'setdata(' + (0, _vegaUtil.stringValue)(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n  scope.addDataPipeline(name, [coll, (0, _transforms.Sieve)({})]);\n  return { data: name, field: 'data' };\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  var counts, a, c, v;\n\n  // get value counts for each domain field\n  counts = fields.map(function (f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field);\n  });\n\n  // sum counts from all fields\n  a = scope.add((0, _transforms.Aggregate)({\n    groupby: _util.keyFieldRef,\n    ops: ['sum'], fields: [scope.fieldRef('count')], as: ['count'],\n    pulse: counts\n  }));\n\n  // collect aggregate output\n  c = scope.add((0, _transforms.Collect)({ pulse: (0, _util.ref)(a) }));\n\n  // extract values for combined domain\n  v = scope.add((0, _transforms.Values)({\n    field: _util.keyFieldRef,\n    sort: scope.sortRef(parseSort(domain.sort, true)),\n    pulse: (0, _util.ref)(c)\n  }));\n\n  return (0, _util.ref)(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if ((0, _vegaUtil.isObject)(sort)) sort.field = 'key';else sort = { field: 'key' };\n    } else if (!sort.field && sort.op !== 'count') {\n      (0, _vegaUtil.error)('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      (0, _vegaUtil.error)('Multiple domain scales can not sort by field.');\n    } else if (multidomain && sort.op && sort.op !== 'count') {\n      (0, _vegaUtil.error)('Multiple domain scales support op count only.');\n    }\n  }\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  var values = fields.map(function (f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  });\n\n  // combine value arrays\n  return (0, _util.ref)(scope.add((0, _transforms.MultiValues)({ values: values })));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  var extents = fields.map(function (f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  });\n\n  // combine extents\n  return (0, _util.ref)(scope.add((0, _transforms.MultiExtent)({ extents: extents })));\n}\n\n// -- SCALE NICE -----\n\nfunction parseScaleNice(nice, params) {\n  params.nice = (0, _vegaUtil.isObject)(nice) ? {\n    interval: parseLiteral(nice.interval),\n    step: parseLiteral(nice.step)\n  } : parseLiteral(nice);\n}\n\n// -- SCALE INTERPOLATION -----\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n}\n\n// -- SCALE RANGE -----\n\nfunction parseScaleRange(spec, scope, params) {\n  var range = spec.range,\n      config = scope.config.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if ((0, _vegaUtil.isString)(range)) {\n    if (config && config.hasOwnProperty(range)) {\n      spec = (0, _vegaUtil.extend)({}, spec, { range: config[range] });\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, { signal: 'width' }];\n    } else if (range === 'height') {\n      range = isOrdinal(spec.type) ? [0, { signal: 'height' }] : [{ signal: 'height' }, 0];\n    } else {\n      (0, _vegaUtil.error)('Unrecognized scale range value: ' + (0, _vegaUtil.stringValue)(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isOrdinal(spec.type) && !(0, _vegaUtil.isArray)(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!(0, _vegaUtil.isArray)(range)) {\n    (0, _vegaUtil.error)('Unsupported range type: ' + (0, _vegaUtil.stringValue)(range));\n  }\n\n  return range.map(function (v) {\n    return parseLiteral(v, scope);\n  });\n}"},"hash":"ef0614ecc96aa7072afb2e6e234059fe","cacheData":{"env":{}}}