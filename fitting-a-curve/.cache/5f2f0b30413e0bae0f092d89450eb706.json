{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-transforms/package.json","includedInParent":true,"mtime":1520278057000},{"name":"./util/Distributions","loc":{"line":1,"column":22}},{"name":"vega-dataflow","loc":{"line":2,"column":32}},{"name":"vega-util","loc":{"line":3,"column":30}},{"name":"d3-array","loc":{"line":4,"column":28}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Density;\n\nvar _Distributions = require('./util/Distributions');\n\nvar _Distributions2 = _interopRequireDefault(_Distributions);\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaUtil = require('vega-util');\n\nvar _d3Array = require('d3-array');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Grid sample points for a probability density. Given a distribution and\n * a sampling extent, will generate points suitable for plotting either\n * PDF (probability density function) or CDF (cumulative distribution\n * function) curves.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.distribution - The probability distribution. This\n *   is an object parameter dependent on the distribution type.\n * @param {string} [params.method='pdf'] - The distribution method to sample.\n *   One of 'pdf' or 'cdf'.\n * @param {Array<number>} [params.extent] - The [min, max] extent over which\n *   to sample the distribution. This argument is required in most cases, but\n *   can be omitted if the distribution (e.g., 'kde') supports a 'data' method\n *   that returns numerical sample points from which the extent can be deduced.\n * @param {number} [params.steps=100] - The number of sampling steps.\n */\nfunction Density(params) {\n  _vegaDataflow.Transform.call(this, null, params);\n}\n\nvar distributions = [{\n  \"key\": { \"function\": \"normal\" },\n  \"params\": [{ \"name\": \"mean\", \"type\": \"number\", \"default\": 0 }, { \"name\": \"stdev\", \"type\": \"number\", \"default\": 1 }]\n}, {\n  \"key\": { \"function\": \"uniform\" },\n  \"params\": [{ \"name\": \"min\", \"type\": \"number\", \"default\": 0 }, { \"name\": \"max\", \"type\": \"number\", \"default\": 1 }]\n}, {\n  \"key\": { \"function\": \"kde\" },\n  \"params\": [{ \"name\": \"field\", \"type\": \"field\", \"required\": true }, { \"name\": \"from\", \"type\": \"data\" }, { \"name\": \"bandwidth\", \"type\": \"number\", \"default\": 0 }]\n}];\n\nvar mixture = {\n  \"key\": { \"function\": \"mixture\" },\n  \"params\": [{ \"name\": \"distributions\", \"type\": \"param\", \"array\": true,\n    \"params\": distributions }, { \"name\": \"weights\", \"type\": \"number\", \"array\": true }]\n};\n\nDensity.Definition = {\n  \"type\": \"Density\",\n  \"metadata\": { \"generates\": true },\n  \"params\": [{ \"name\": \"extent\", \"type\": \"number\", \"array\": true, \"length\": 2 }, { \"name\": \"steps\", \"type\": \"number\", \"default\": 100 }, { \"name\": \"method\", \"type\": \"string\", \"default\": \"pdf\",\n    \"values\": [\"pdf\", \"cdf\"] }, { \"name\": \"distribution\", \"type\": \"param\",\n    \"params\": distributions.concat(mixture) }, { \"name\": \"as\", \"type\": \"string\", \"array\": true,\n    \"default\": [\"value\", \"density\"] }]\n};\n\nvar prototype = (0, _vegaUtil.inherits)(Density, _vegaDataflow.Transform);\n\nprototype.transform = function (_, pulse) {\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n  if (!this.value || pulse.changed() || _.modified()) {\n    var dist = (0, _Distributions2.default)(_.distribution, source(pulse)),\n        method = _.method || 'pdf';\n\n    if (method !== 'pdf' && method !== 'cdf') {\n      (0, _vegaUtil.error)('Invalid density method: ' + method);\n    }\n    if (!_.extent && !dist.data) {\n      (0, _vegaUtil.error)('Missing density extent parameter.');\n    }\n    method = dist[method];\n\n    var as = _.as || ['value', 'density'],\n        domain = _.extent || (0, _d3Array.extent)(dist.data()),\n        step = (domain[1] - domain[0]) / (_.steps || 100),\n        values = (0, _d3Array.range)(domain[0], domain[1] + step / 2, step).map(function (v) {\n      var tuple = {};\n      tuple[as[0]] = v;\n      tuple[as[1]] = method(v);\n      return (0, _vegaDataflow.ingest)(tuple);\n    });\n\n    if (this.value) out.rem = this.value;\n    this.value = out.add = out.source = values;\n  }\n\n  return out;\n};\n\nfunction source(pulse) {\n  return function () {\n    return pulse.materialize(pulse.SOURCE).source;\n  };\n}"},"hash":"66fb47987d0cc67aaac3579fb8524d7f","cacheData":{"env":{}}}