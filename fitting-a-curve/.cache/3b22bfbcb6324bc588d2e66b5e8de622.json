{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-view-transforms/package.json","includedInParent":true,"mtime":1518586109000},{"name":"./gridLayout","loc":{"line":1,"column":25}},{"name":"./orient","loc":{"line":2,"column":39}},{"name":"vega-dataflow","loc":{"line":3,"column":24}},{"name":"vega-scenegraph","loc":{"line":4,"column":34}},{"name":"vega-util","loc":{"line":5,"column":23}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ViewLayout;\n\nvar _gridLayout = require('./gridLayout');\n\nvar _orient = require('./orient');\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaScenegraph = require('vega-scenegraph');\n\nvar _vegaUtil = require('vega-util');\n\nvar Fit = 'fit',\n    FitX = 'fit-x',\n    FitY = 'fit-y',\n    Pad = 'pad',\n    None = 'none',\n    Padding = 'padding';\n\nvar AxisRole = 'axis',\n    TitleRole = 'title',\n    FrameRole = 'frame',\n    LegendRole = 'legend',\n    ScopeRole = 'scope',\n    RowHeader = 'row-header',\n    RowFooter = 'row-footer',\n    ColHeader = 'column-header',\n    ColFooter = 'column-footer';\n\nvar AxisOffset = 0.5,\n    tempBounds = new _vegaScenegraph.Bounds();\n\n/**\n * Layout view elements such as axes and legends.\n * Also performs size adjustments.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - Scenegraph mark of groups to layout.\n */\nfunction ViewLayout(params) {\n  _vegaDataflow.Transform.call(this, null, params);\n}\n\nvar prototype = (0, _vegaUtil.inherits)(ViewLayout, _vegaDataflow.Transform);\n\nprototype.transform = function (_, pulse) {\n  // TODO incremental update, output?\n  var view = pulse.dataflow;\n  _.mark.items.forEach(function (group) {\n    if (_.layout) (0, _gridLayout.gridLayout)(view, group, _.layout);\n    layoutGroup(view, group, _);\n  });\n  return pulse;\n};\n\nfunction layoutGroup(view, group, _) {\n  var items = group.items,\n      width = Math.max(0, group.width || 0),\n      height = Math.max(0, group.height || 0),\n      viewBounds = new _vegaScenegraph.Bounds().set(0, 0, width, height),\n      axisBounds = viewBounds.clone(),\n      xBounds = viewBounds.clone(),\n      yBounds = viewBounds.clone(),\n      legends = [],\n      title,\n      mark,\n      flow,\n      b,\n      i,\n      n;\n\n  // layout axes, gather legends, collect bounds\n  for (i = 0, n = items.length; i < n; ++i) {\n    mark = items[i];\n    switch (mark.role) {\n      case AxisRole:\n        axisBounds.union(b = layoutAxis(view, mark, width, height));\n        (isYAxis(mark) ? xBounds : yBounds).union(b);\n        break;\n      case TitleRole:\n        title = mark;break;\n      case LegendRole:\n        legends.push(mark);break;\n      case FrameRole:\n      case ScopeRole:\n      case RowHeader:\n      case RowFooter:\n      case ColHeader:\n      case ColFooter:\n        xBounds.union(mark.bounds);\n        yBounds.union(mark.bounds);\n        break;\n      default:\n        viewBounds.union(mark.bounds);\n    }\n  }\n\n  // layout title, adjust bounds\n  if (title) {\n    axisBounds.union(b = layoutTitle(view, title, axisBounds));\n    (isYAxis(title) ? xBounds : yBounds).union(b);\n  }\n\n  // layout legends, adjust viewBounds\n  if (legends.length) {\n    flow = { left: 0, right: 0, top: 0, bottom: 0, margin: _.legendMargin || 8 };\n\n    for (i = 0, n = legends.length; i < n; ++i) {\n      b = layoutLegend(view, legends[i], flow, xBounds, yBounds, width, height);\n      if (_.autosize && _.autosize.type === Fit) {\n        // for autosize fit, incorporate the orthogonal dimension only\n        // legends that overrun the chart area will then be clipped\n        // otherwise the chart area gets reduced to nothing!\n        var orient = legends[i].items[0].datum.orient;\n        if (orient === _orient.Left || orient === _orient.Right) {\n          viewBounds.add(b.x1, 0).add(b.x2, 0);\n        } else if (orient === _orient.Top || orient === _orient.Bottom) {\n          viewBounds.add(0, b.y1).add(0, b.y2);\n        }\n      } else {\n        viewBounds.union(b);\n      }\n    }\n  }\n\n  // perform size adjustment\n  viewBounds.union(xBounds).union(yBounds).union(axisBounds);\n  layoutSize(view, group, viewBounds, _);\n}\n\nfunction set(item, property, value) {\n  if (item[property] === value) {\n    return 0;\n  } else {\n    item[property] = value;\n    return 1;\n  }\n}\n\nfunction isYAxis(mark) {\n  var orient = mark.items[0].datum.orient;\n  return orient === _orient.Left || orient === _orient.Right;\n}\n\nfunction axisIndices(datum) {\n  var index = +datum.grid;\n  return [datum.ticks ? index++ : -1, // ticks index\n  datum.labels ? index++ : -1, // labels index\n  index + +datum.domain // title index\n  ];\n}\n\nfunction layoutAxis(view, axis, width, height) {\n  var item = axis.items[0],\n      datum = item.datum,\n      orient = datum.orient,\n      indices = axisIndices(datum),\n      range = item.range,\n      offset = item.offset,\n      position = item.position,\n      minExtent = item.minExtent,\n      maxExtent = item.maxExtent,\n      title = datum.title && item.items[indices[2]].items[0],\n      titlePadding = item.titlePadding,\n      bounds = item.bounds,\n      x = 0,\n      y = 0,\n      i,\n      s;\n\n  tempBounds.clear().union(bounds);\n  bounds.clear();\n  if ((i = indices[0]) > -1) bounds.union(item.items[i].bounds);\n  if ((i = indices[1]) > -1) bounds.union(item.items[i].bounds);\n\n  // position axis group and title\n  switch (orient) {\n    case _orient.Top:\n      x = position || 0;\n      y = -offset;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));\n      if (title) {\n        if (title.auto) {\n          s += titlePadding;\n          title.y = -s;\n          s += title.bounds.height();\n          bounds.add(title.bounds.x1, 0).add(title.bounds.x2, 0);\n        } else {\n          bounds.union(title.bounds);\n        }\n      }\n      bounds.add(0, -s).add(range, 0);\n      break;\n    case _orient.Left:\n      x = -offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));\n      if (title) {\n        if (title.auto) {\n          s += titlePadding;\n          title.x = -s;\n          s += title.bounds.width();\n          bounds.add(0, title.bounds.y1).add(0, title.bounds.y2);\n        } else {\n          bounds.union(title.bounds);\n        }\n      }\n      bounds.add(-s, 0).add(0, range);\n      break;\n    case _orient.Right:\n      x = width + offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));\n      if (title) {\n        if (title.auto) {\n          s += titlePadding;\n          title.x = s;\n          s += title.bounds.width();\n          bounds.add(0, title.bounds.y1).add(0, title.bounds.y2);\n        } else {\n          bounds.union(title.bounds);\n        }\n      }\n      bounds.add(0, 0).add(s, range);\n      break;\n    case _orient.Bottom:\n      x = position || 0;\n      y = height + offset;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));\n      if (title) if (title.auto) {\n        s += titlePadding;\n        title.y = s;\n        s += title.bounds.height();\n        bounds.add(title.bounds.x1, 0).add(title.bounds.x2, 0);\n      } else {\n        bounds.union(title.bounds);\n      }\n      bounds.add(0, 0).add(range, s);\n      break;\n    default:\n      x = item.x;\n      y = item.y;\n  }\n\n  // update bounds\n  (0, _vegaScenegraph.boundStroke)(bounds.translate(x, y), item);\n\n  if (set(item, 'x', x + AxisOffset) | set(item, 'y', y + AxisOffset)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n\n  return item.mark.bounds.clear().union(bounds);\n}\n\nfunction layoutTitle(view, title, axisBounds) {\n  var item = title.items[0],\n      datum = item.datum,\n      orient = datum.orient,\n      offset = item.offset,\n      bounds = item.bounds,\n      x = 0,\n      y = 0;\n\n  tempBounds.clear().union(bounds);\n\n  // position axis group and title\n  switch (orient) {\n    case _orient.Top:\n      x = item.x;\n      y = axisBounds.y1 - offset;\n      break;\n    case _orient.Left:\n      x = axisBounds.x1 - offset;\n      y = item.y;\n      break;\n    case _orient.Right:\n      x = axisBounds.x2 + offset;\n      y = item.y;\n      break;\n    case _orient.Bottom:\n      x = item.x;\n      y = axisBounds.y2 + offset;\n      break;\n    default:\n      x = item.x;\n      y = item.y;\n  }\n\n  bounds.translate(x - item.x, y - item.y);\n  if (set(item, 'x', x) | set(item, 'y', y)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n\n  // update bounds\n  return title.bounds.clear().union(bounds);\n}\n\nfunction layoutLegend(view, legend, flow, xBounds, yBounds, width, height) {\n  var item = legend.items[0],\n      datum = item.datum,\n      orient = datum.orient,\n      offset = item.offset,\n      bounds = item.bounds,\n      x = 0,\n      y = 0,\n      w,\n      h,\n      axisBounds;\n\n  if (orient === _orient.Top || orient === _orient.Bottom) {\n    axisBounds = yBounds, x = flow[orient];\n  } else if (orient === _orient.Left || orient === _orient.Right) {\n    axisBounds = xBounds;\n    y = flow[orient];\n  }\n\n  tempBounds.clear().union(bounds);\n  bounds.clear();\n\n  // aggregate bounds to determine size\n  // shave off 1 pixel because it looks better...\n  item.items.forEach(function (_) {\n    bounds.union(_.bounds);\n  });\n  w = Math.round(bounds.width()) + 2 * item.padding - 1;\n  h = Math.round(bounds.height()) + 2 * item.padding - 1;\n\n  switch (orient) {\n    case _orient.Left:\n      x -= w + offset - Math.floor(axisBounds.x1);\n      flow.left += h + flow.margin;\n      break;\n    case _orient.Right:\n      x += offset + Math.ceil(axisBounds.x2);\n      flow.right += h + flow.margin;\n      break;\n    case _orient.Top:\n      y -= h + offset - Math.floor(axisBounds.y1);\n      flow.top += w + flow.margin;\n      break;\n    case _orient.Bottom:\n      y += offset + Math.ceil(axisBounds.y2);\n      flow.bottom += w + flow.margin;\n      break;\n    case 'top-left':\n      x += offset;\n      y += offset;\n      break;\n    case 'top-right':\n      x += width - w - offset;\n      y += offset;\n      break;\n    case 'bottom-left':\n      x += offset;\n      y += height - h - offset;\n      break;\n    case 'bottom-right':\n      x += width - w - offset;\n      y += height - h - offset;\n      break;\n    default:\n      x = item.x;\n      y = item.y;\n  }\n\n  // update bounds\n  (0, _vegaScenegraph.boundStroke)(bounds.set(x, y, x + w, y + h), item);\n\n  // update legend layout\n  if (set(item, 'x', x) | set(item, 'width', w) | set(item, 'y', y) | set(item, 'height', h)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n\n  return item.mark.bounds.clear().union(bounds);\n}\n\nfunction layoutSize(view, group, viewBounds, _) {\n  var auto = _.autosize || {},\n      type = auto.type,\n      viewWidth = view._width,\n      viewHeight = view._height,\n      padding = view.padding();\n\n  if (view._autosize < 1 || !type) return;\n\n  var width = Math.max(0, group.width || 0),\n      left = Math.max(0, Math.ceil(-viewBounds.x1)),\n      right = Math.max(0, Math.ceil(viewBounds.x2 - width)),\n      height = Math.max(0, group.height || 0),\n      top = Math.max(0, Math.ceil(-viewBounds.y1)),\n      bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));\n\n  if (auto.contains === Padding) {\n    viewWidth -= padding.left + padding.right;\n    viewHeight -= padding.top + padding.bottom;\n  }\n\n  if (type === None) {\n    left = 0;\n    top = 0;\n    width = viewWidth;\n    height = viewHeight;\n  } else if (type === Fit) {\n    width = Math.max(0, viewWidth - left - right);\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === FitX) {\n    width = Math.max(0, viewWidth - left - right);\n    viewHeight = height + top + bottom;\n  } else if (type === FitY) {\n    viewWidth = width + left + right;\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === Pad) {\n    viewWidth = width + left + right;\n    viewHeight = height + top + bottom;\n  }\n\n  view._resizeView(viewWidth, viewHeight, width, height, [left, top], auto.resize);\n}"},"hash":"d5ad7f6aa2da4378ffc68fcfe524190a","cacheData":{"env":{}}}