{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-crossfilter/package.json","includedInParent":true,"mtime":1501881708000},{"name":"vega-dataflow","loc":{"line":1,"column":24}},{"name":"vega-util","loc":{"line":2,"column":23}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ResolveFilter;\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaUtil = require('vega-util');\n\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\nfunction ResolveFilter(params) {\n  _vegaDataflow.Transform.call(this, null, params);\n}\n\nResolveFilter.Definition = {\n  \"type\": \"ResolveFilter\",\n  \"metadata\": {},\n  \"params\": [{ \"name\": \"ignore\", \"type\": \"number\", \"required\": true,\n    \"description\": \"A bit mask indicating which filters to ignore.\" }, { \"name\": \"filter\", \"type\": \"object\", \"required\": true,\n    \"description\": \"Per-tuple filter bitmaps from a CrossFilter transform.\" }]\n};\n\nvar prototype = (0, _vegaUtil.inherits)(ResolveFilter, _vegaDataflow.Transform);\n\nprototype.transform = function (_, pulse) {\n  var ignore = ~(_.ignore || 0),\n      // bit mask where zeros -> dims to ignore\n  bitmap = _.filter,\n      mask = bitmap.mask;\n\n  // exit early if no relevant filter changes\n  if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n  var output = pulse.fork(pulse.ALL),\n      data = bitmap.data(),\n      curr = bitmap.curr(),\n      prev = bitmap.prev(),\n      pass = function (k) {\n    return !(curr[k] & ignore) ? data[k] : null;\n  };\n\n  // propagate all mod tuples that pass the filter\n  output.filter(output.MOD, pass);\n\n  // determine add & rem tuples via filter functions\n  // for efficiency, we do *not* populate new arrays,\n  // instead we add filter functions applied downstream\n\n  if (!(mask & mask - 1)) {\n    // only one filter changed\n    output.filter(output.ADD, pass);\n    output.filter(output.REM, function (k) {\n      return (curr[k] & ignore) === mask ? data[k] : null;\n    });\n  } else {\n    // multiple filters changed\n    output.filter(output.ADD, function (k) {\n      var c = curr[k] & ignore,\n          f = !c && c ^ prev[k] & ignore;\n      return f ? data[k] : null;\n    });\n    output.filter(output.REM, function (k) {\n      var c = curr[k] & ignore,\n          f = c && !(c ^ (c ^ prev[k] & ignore));\n      return f ? data[k] : null;\n    });\n  }\n\n  // add filter to source data in case of reflow...\n  return output.filter(output.SOURCE, function (t) {\n    return pass(t._index);\n  });\n};"},"hash":"86a580b732eb651142ebe6811283ca9d","cacheData":{"env":{}}}