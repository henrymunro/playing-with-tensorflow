{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-transforms/package.json","includedInParent":true,"mtime":1520278057000},{"name":"./Aggregate","loc":{"line":1,"column":22}},{"name":"./util/AggregateOps","loc":{"line":2,"column":32}},{"name":"vega-util","loc":{"line":3,"column":31}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = JoinAggregate;\n\nvar _Aggregate = require('./Aggregate');\n\nvar _Aggregate2 = _interopRequireDefault(_Aggregate);\n\nvar _AggregateOps = require('./util/AggregateOps');\n\nvar _vegaUtil = require('vega-util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Extend input tuples with aggregate values.\n * Calcuates aggregate values and joins them with the input stream.\n * @constructor\n */\nfunction JoinAggregate(params) {\n  _Aggregate2.default.call(this, params);\n}\n\nJoinAggregate.Definition = {\n  \"type\": \"JoinAggregate\",\n  \"metadata\": { \"modifies\": true },\n  \"params\": [{ \"name\": \"groupby\", \"type\": \"field\", \"array\": true }, { \"name\": \"fields\", \"type\": \"field\", \"null\": true, \"array\": true }, { \"name\": \"ops\", \"type\": \"enum\", \"array\": true, \"values\": _AggregateOps.ValidAggregateOps }, { \"name\": \"as\", \"type\": \"string\", \"null\": true, \"array\": true }, { \"name\": \"key\", \"type\": \"field\" }]\n};\n\nvar prototype = (0, _vegaUtil.inherits)(JoinAggregate, _Aggregate2.default);\n\nprototype.transform = function (_, pulse) {\n  var aggr = this,\n      mod = _.modified(),\n      cells;\n\n  // process all input tuples to calculate aggregates\n  if (aggr.value && (mod || pulse.modified(aggr._inputs))) {\n    cells = aggr.value = mod ? aggr.init(_) : {};\n    pulse.visit(pulse.SOURCE, function (t) {\n      aggr.add(t);\n    });\n  } else {\n    cells = aggr.value = aggr.value || this.init(_);\n    pulse.visit(pulse.REM, function (t) {\n      aggr.rem(t);\n    });\n    pulse.visit(pulse.ADD, function (t) {\n      aggr.add(t);\n    });\n  }\n\n  // update aggregation cells\n  aggr.changes();\n\n  // write aggregate values to input tuples\n  pulse.visit(pulse.SOURCE, function (t) {\n    (0, _vegaUtil.extend)(t, cells[aggr.cellkey(t)].tuple);\n  });\n\n  return pulse.reflow(mod).modifies(this._outputs);\n};\n\nprototype.changes = function () {\n  var adds = this._adds,\n      mods = this._mods,\n      i,\n      n;\n\n  for (i = 0, n = this._alen; i < n; ++i) {\n    this.celltuple(adds[i]);\n    adds[i] = null; // for garbage collection\n  }\n\n  for (i = 0, n = this._mlen; i < n; ++i) {\n    this.celltuple(mods[i]);\n    mods[i] = null; // for garbage collection\n  }\n\n  this._alen = this._mlen = 0; // reset list of active cells\n};"},"hash":"f84dd670f6c9df280c15d5b8549f756f","cacheData":{"env":{}}}