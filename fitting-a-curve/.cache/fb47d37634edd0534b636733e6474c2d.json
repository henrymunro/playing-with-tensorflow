{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-transforms/package.json","includedInParent":true,"mtime":1520278057000},{"name":"vega-dataflow","loc":{"line":1,"column":32}},{"name":"vega-util","loc":{"line":2,"column":44}},{"name":"d3-array","loc":{"line":3,"column":37}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Impute;\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaUtil = require('vega-util');\n\nvar _d3Array = require('d3-array');\n\nvar Methods = {\n  value: 'value',\n  median: _d3Array.median,\n  mean: _d3Array.mean,\n  min: _d3Array.min,\n  max: _d3Array.max\n};\n\nvar Empty = [];\n\n/**\n * Impute missing values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to impute.\n * @param {Array<function(object): *>} [params.groupby] - An array of\n *   accessors to determine series within which to perform imputation.\n * @param {function(object): *} params.key - An accessor for a key value.\n *   Each key value should be unique within a group. New tuples will be\n *   imputed for any key values that are not found within a group.\n * @param {Array<*>} [params.keyvals] - Optional array of required key\n *   values. New tuples will be imputed for any key values that are not\n *   found within a group. In addition, these values will be automatically\n *   augmented with the key values observed in the input data.\n * @param {string} [method='value'] - The imputation method to use. One of\n *   'value', 'mean', 'median', 'max', 'min'.\n * @param {*} [value=0] - The constant value to use for imputation\n *   when using method 'value'.\n */\nfunction Impute(params) {\n  _vegaDataflow.Transform.call(this, [], params);\n}\n\nImpute.Definition = {\n  \"type\": \"Impute\",\n  \"metadata\": { \"generates\": true, \"changes\": true },\n  \"params\": [{ \"name\": \"field\", \"type\": \"field\", \"required\": true }, { \"name\": \"key\", \"type\": \"field\", \"required\": true }, { \"name\": \"keyvals\", \"array\": true }, { \"name\": \"groupby\", \"type\": \"field\", \"array\": true }, { \"name\": \"method\", \"type\": \"enum\", \"default\": \"value\",\n    \"values\": [\"value\", \"mean\", \"median\", \"max\", \"min\"] }, { \"name\": \"value\", \"default\": 0 }]\n};\n\nvar prototype = (0, _vegaUtil.inherits)(Impute, _vegaDataflow.Transform);\n\nfunction getValue(_) {\n  var m = _.method || Methods.value,\n      v;\n\n  if (Methods[m] == null) {\n    (0, _vegaUtil.error)('Unrecognized imputation method: ' + m);\n  } else if (m === Methods.value) {\n    v = _.value !== undefined ? _.value : 0;\n    return function () {\n      return v;\n    };\n  } else {\n    return Methods[m];\n  }\n}\n\nfunction getField(_) {\n  var f = _.field;\n  return function (t) {\n    return t ? f(t) : NaN;\n  };\n}\n\nprototype.transform = function (_, pulse) {\n  var out = pulse.fork(pulse.ALL),\n      impute = getValue(_),\n      field = getField(_),\n      fName = (0, _vegaUtil.accessorName)(_.field),\n      kName = (0, _vegaUtil.accessorName)(_.key),\n      gNames = (_.groupby || []).map(_vegaUtil.accessorName),\n      groups = partition(pulse.source, _.groupby, _.key, _.keyvals),\n      curr = [],\n      prev = this.value,\n      m = groups.domain.length,\n      group,\n      value,\n      gVals,\n      kVal,\n      g,\n      i,\n      j,\n      l,\n      n,\n      t;\n\n  for (g = 0, l = groups.length; g < l; ++g) {\n    group = groups[g];\n    gVals = group.values;\n    value = NaN;\n\n    // add tuples for missing values\n    for (j = 0; j < m; ++j) {\n      if (group[j] != null) continue;\n      kVal = groups.domain[j];\n\n      t = { _impute: true };\n      for (i = 0, n = gVals.length; i < n; ++i) t[gNames[i]] = gVals[i];\n      t[kName] = kVal;\n      t[fName] = isNaN(value) ? value = impute(group, field) : value;\n\n      curr.push((0, _vegaDataflow.ingest)(t));\n    }\n  }\n\n  // update pulse with imputed tuples\n  if (curr.length) out.add = out.materialize(out.ADD).add.concat(curr);\n  if (prev.length) out.rem = out.materialize(out.REM).rem.concat(prev);\n  this.value = curr;\n\n  return out;\n};\n\nfunction partition(data, groupby, key, keyvals) {\n  var get = function (f) {\n    return f(t);\n  },\n      groups = [],\n      domain = keyvals ? keyvals.slice() : [],\n      kMap = {},\n      gMap = {},\n      gVals,\n      gKey,\n      group,\n      i,\n      j,\n      k,\n      n,\n      t;\n\n  domain.forEach(function (k, i) {\n    kMap[k] = i + 1;\n  });\n\n  for (i = 0, n = data.length; i < n; ++i) {\n    t = data[i];\n    k = key(t);\n    j = kMap[k] || (kMap[k] = domain.push(k));\n\n    gKey = (gVals = groupby ? groupby.map(get) : Empty) + '';\n    if (!(group = gMap[gKey])) {\n      group = gMap[gKey] = [];\n      groups.push(group);\n      group.values = gVals;\n    }\n    group[j - 1] = t;\n  }\n\n  groups.domain = domain;\n  return groups;\n}"},"hash":"648d53f68c471030d2624a07e9d16137","cacheData":{"env":{}}}