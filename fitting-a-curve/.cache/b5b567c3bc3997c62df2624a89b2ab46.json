{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-scenegraph/package.json","includedInParent":true,"mtime":1518728314000},{"name":"../Bounds","loc":{"line":1,"column":19}},{"name":"../util/text","loc":{"line":2,"column":51}},{"name":"../util/visit","loc":{"line":3,"column":20}},{"name":"../util/canvas/fill","loc":{"line":4,"column":17}},{"name":"../util/canvas/pick","loc":{"line":5,"column":19}},{"name":"../util/canvas/stroke","loc":{"line":6,"column":19}},{"name":"../util/svg/translate","loc":{"line":7,"column":22}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Bounds = require('../Bounds');\n\nvar _Bounds2 = _interopRequireDefault(_Bounds);\n\nvar _text = require('../util/text');\n\nvar _visit = require('../util/visit');\n\nvar _fill = require('../util/canvas/fill');\n\nvar _fill2 = _interopRequireDefault(_fill);\n\nvar _pick = require('../util/canvas/pick');\n\nvar _stroke = require('../util/canvas/stroke');\n\nvar _stroke2 = _interopRequireDefault(_stroke);\n\nvar _translate = require('../util/svg/translate');\n\nvar _translate2 = _interopRequireDefault(_translate);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar textAlign = {\n  'left': 'start',\n  'center': 'middle',\n  'right': 'end'\n};\n\nvar tempBounds = new _Bounds2.default();\n\nfunction attr(emit, item) {\n  var dx = item.dx || 0,\n      dy = (item.dy || 0) + (0, _text.offset)(item),\n      x = item.x || 0,\n      y = item.y || 0,\n      a = item.angle || 0,\n      r = item.radius || 0,\n      t;\n\n  if (r) {\n    t = (item.theta || 0) - Math.PI / 2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  emit('text-anchor', textAlign[item.align] || 'start');\n\n  if (a) {\n    t = (0, _translate2.default)(x, y) + ' rotate(' + a + ')';\n    if (dx || dy) t += ' ' + (0, _translate2.default)(dx, dy);\n  } else {\n    t = (0, _translate2.default)(x + dx, y + dy);\n  }\n  emit('transform', t);\n}\n\nfunction bound(bounds, item, noRotate) {\n  var h = _text.textMetrics.height(item),\n      a = item.align,\n      r = item.radius || 0,\n      x = item.x || 0,\n      y = item.y || 0,\n      dx = item.dx || 0,\n      dy = (item.dy || 0) + (0, _text.offset)(item) - Math.round(0.8 * h),\n      // use 4/5 offset\n  w,\n      t;\n\n  if (r) {\n    t = (item.theta || 0) - Math.PI / 2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal alignment\n  w = _text.textMetrics.width(item);\n  if (a === 'center') {\n    dx -= w / 2;\n  } else if (a === 'right') {\n    dx -= w;\n  } else {\n    // left by default, do nothing\n  }\n\n  bounds.set(dx += x, dy += y, dx + w, dy + h);\n  if (item.angle && !noRotate) {\n    bounds.rotate(item.angle * Math.PI / 180, x, y);\n  }\n  return bounds.expand(noRotate || !w ? 0 : 1);\n}\n\nfunction draw(context, scene, bounds) {\n  (0, _visit.visit)(scene, function (item) {\n    var opacity, x, y, r, t, str;\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n    if (!(str = (0, _text.textValue)(item))) return; // get text string\n\n    opacity = item.opacity == null ? 1 : item.opacity;\n    if (opacity === 0) return;\n\n    context.font = (0, _text.font)(item);\n    context.textAlign = item.align || 'left';\n\n    x = item.x || 0;\n    y = item.y || 0;\n    if (r = item.radius) {\n      t = (item.theta || 0) - Math.PI / 2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (item.angle) {\n      context.save();\n      context.translate(x, y);\n      context.rotate(item.angle * Math.PI / 180);\n      x = y = 0; // reset x, y\n    }\n    x += item.dx || 0;\n    y += (item.dy || 0) + (0, _text.offset)(item);\n\n    if (item.fill && (0, _fill2.default)(context, item, opacity)) {\n      context.fillText(str, x, y);\n    }\n    if (item.stroke && (0, _stroke2.default)(context, item, opacity)) {\n      context.strokeText(str, x, y);\n    }\n    if (item.angle) context.restore();\n  });\n}\n\nfunction hit(context, item, x, y, gx, gy) {\n  if (item.fontSize <= 0) return false;\n  if (!item.angle) return true; // bounds sufficient if no rotation\n\n  // project point into space of unrotated bounds\n  var b = bound(tempBounds, item, true),\n      a = -item.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      ix = item.x,\n      iy = item.y,\n      px = cos * gx - sin * gy + (ix - ix * cos + iy * sin),\n      py = sin * gx + cos * gy + (iy - ix * sin - iy * cos);\n\n  return b.contains(px, py);\n}\n\nexports.default = {\n  type: 'text',\n  tag: 'text',\n  nested: false,\n  attr: attr,\n  bound: bound,\n  draw: draw,\n  pick: (0, _pick.pick)(hit)\n};"},"hash":"f5e519cc98f7cc7d7298f456fecc2f4e","cacheData":{"env":{}}}