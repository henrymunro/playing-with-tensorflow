{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-hierarchy/package.json","includedInParent":true,"mtime":1518550386000},{"name":"vega-dataflow","loc":{"line":1,"column":41}},{"name":"vega-util","loc":{"line":2,"column":30}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = TreeLinks;\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaUtil = require('vega-util');\n\n/**\n * Generate tuples representing links between tree nodes.\n * The resulting tuples will contain 'source' and 'target' fields,\n * which point to parent and child node tuples, respectively.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.key] - Unique key field for each tuple.\n *   If not provided, the tuple id field is used.\n */\nfunction TreeLinks(params) {\n  _vegaDataflow.Transform.call(this, {}, params);\n}\n\nTreeLinks.Definition = {\n  \"type\": \"TreeLinks\",\n  \"metadata\": { \"tree\": true, \"generates\": true, \"changes\": true },\n  \"params\": [{ \"name\": \"key\", \"type\": \"field\" }]\n};\n\nvar prototype = (0, _vegaUtil.inherits)(TreeLinks, _vegaDataflow.Transform);\n\nfunction parentTuple(node) {\n  var p;\n  return node.parent && (p = node.parent.data) && (0, _vegaDataflow.tupleid)(p) != null && p;\n}\n\nprototype.transform = function (_, pulse) {\n  if (!pulse.source || !pulse.source.root) {\n    (0, _vegaUtil.error)('TreeLinks transform requires a backing tree data source.');\n  }\n\n  var root = pulse.source.root,\n      nodes = root.lookup,\n      links = this.value,\n      key = _.key || _vegaDataflow.tupleid,\n      mods = {},\n      out = pulse.fork();\n\n  function modify(id) {\n    var link = links[id];\n    if (link) {\n      mods[id] = 1;\n      out.mod.push(link);\n    }\n  }\n\n  // process removed tuples\n  // assumes that if a parent node is removed the child will be, too.\n  pulse.visit(pulse.REM, function (t) {\n    var id = key(t),\n        link = links[id];\n    if (link) {\n      delete links[id];\n      out.rem.push(link);\n    }\n  });\n\n  // create new link instances for added nodes with valid parents\n  pulse.visit(pulse.ADD, function (t) {\n    var id = key(t),\n        p;\n    if (p = parentTuple(nodes[id])) {\n      out.add.push(links[id] = (0, _vegaDataflow.ingest)({ source: p, target: t }));\n      mods[id] = 1;\n    }\n  });\n\n  // process modified nodes and their children\n  pulse.visit(pulse.MOD, function (t) {\n    var id = key(t),\n        node = nodes[id],\n        kids = node.children;\n\n    modify(id);\n    if (kids) for (var i = 0, n = kids.length; i < n; ++i) {\n      if (!mods[id = key(kids[i].data)]) modify(id);\n    }\n  });\n\n  return out;\n};"},"hash":"8d7ef7eb941c6ff9d4c3e0e93fce4316","cacheData":{"env":{}}}