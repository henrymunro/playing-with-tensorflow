{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/topojson-client/package.json","includedInParent":true,"mtime":1490936790000},{"name":"./bbox","loc":{"line":1,"column":17}},{"name":"./untransform","loc":{"line":2,"column":24}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be â‰¥2\");\n    box = topology.bbox || (0, _bbox2.default)(topology);\n    var x0 = box[0],\n        y0 = box[1],\n        x1 = box[2],\n        y1 = box[3],\n        n;\n    transform = { scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0] };\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = (0, _untransform2.default)(transform),\n      box,\n      key,\n      inputs = topology.objects,\n      outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\":\n        output = { type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry) };break;\n      case \"Point\":\n        output = { type: \"Point\", coordinates: quantizePoint(input.coordinates) };break;\n      case \"MultiPoint\":\n        output = { type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint) };break;\n      default:\n        return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0,\n        j = 1,\n        n = input.length,\n        p,\n        output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n};\n\nvar _bbox = require(\"./bbox\");\n\nvar _bbox2 = _interopRequireDefault(_bbox);\n\nvar _untransform = require(\"./untransform\");\n\nvar _untransform2 = _interopRequireDefault(_untransform);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }"},"hash":"7293aa8e9524e5a89b1347893813739c","cacheData":{"env":{}}}