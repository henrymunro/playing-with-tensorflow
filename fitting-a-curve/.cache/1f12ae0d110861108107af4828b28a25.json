{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-view-transforms/package.json","includedInParent":true,"mtime":1518586109000},{"name":"./orient","loc":{"line":1,"column":26}},{"name":"vega-dataflow","loc":{"line":2,"column":24}},{"name":"vega-scenegraph","loc":{"line":3,"column":21}},{"name":"vega-util","loc":{"line":4,"column":29}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Overlap;\n\nvar _orient = require('./orient');\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaScenegraph = require('vega-scenegraph');\n\nvar _vegaUtil = require('vega-util');\n\n/**\n * Analyze items for overlap, changing opacity to hide items with\n * overlapping bounding boxes. This transform will preserve at least\n * two items (e.g., first and last) even if overlap persists.\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting items.\n * @param {object} [params.method] - The overlap removal method to apply.\n *   One of 'parity' (default, hide every other item until there is no\n *   more overlap) or 'greedy' (sequentially scan and hide and items that\n *   overlap with the last visible item).\n * @param {object} [params.boundScale] - A scale whose range should be used\n *   to bound the items. Items exceeding the bounds of the scale range\n *   will be treated as overlapping. If null or undefined, no bounds check\n *   will be applied.\n * @param {object} [params.boundOrient] - The orientation of the scale\n *   (top, bottom, left, or right) used to bound items. This parameter is\n *   ignored if boundScale is null or undefined.\n * @param {object} [params.boundTolerance] - The tolerance in pixels for\n *   bound inclusion testing (default 1). This specifies by how many pixels\n *   an item's bounds may exceed the scale range bounds and not be culled.\n * @constructor\n */\nfunction Overlap(params) {\n  _vegaDataflow.Transform.call(this, null, params);\n}\n\nvar prototype = (0, _vegaUtil.inherits)(Overlap, _vegaDataflow.Transform);\n\nvar methods = {\n  parity: function (items) {\n    return items.filter(function (item, i) {\n      return i % 2 ? item.opacity = 0 : 1;\n    });\n  },\n  greedy: function (items) {\n    var a;\n    return items.filter(function (b, i) {\n      if (!i || !intersect(a.bounds, b.bounds)) {\n        a = b;\n        return 1;\n      } else {\n        return b.opacity = 0;\n      }\n    });\n  }\n};\n\n// compute bounding box intersection\n// allow 1 pixel of overlap tolerance\nfunction intersect(a, b) {\n  return !(a.x2 - 1 < b.x1 || a.x1 + 1 > b.x2 || a.y2 - 1 < b.y1 || a.y1 + 1 > b.y2);\n}\n\nfunction hasOverlap(items) {\n  for (var i = 1, n = items.length, a = items[0].bounds, b; i < n; a = b, ++i) {\n    if (intersect(a, b = items[i].bounds)) return true;\n  }\n}\n\nfunction hasBounds(item) {\n  var b = item.bounds;\n  return b.width() > 1 && b.height() > 1;\n}\n\nfunction boundTest(scale, orient, tolerance) {\n  var range = scale.range(),\n      b = new _vegaScenegraph.Bounds();\n\n  if (orient === _orient.Top || orient === _orient.Bottom) {\n    b.set(range[0], -Infinity, range[1], +Infinity);\n  } else {\n    b.set(-Infinity, range[0], +Infinity, range[1]);\n  }\n  b.expand(tolerance || 1);\n\n  return function (item) {\n    return b.encloses(item.bounds);\n  };\n}\n\nprototype.transform = function (_, pulse) {\n  var reduce = methods[_.method] || methods.parity,\n      source = pulse.materialize(pulse.SOURCE).source;\n\n  if (!source) return;\n\n  if (_.sort) {\n    source = source.slice().sort(_.sort);\n  }\n\n  if (_.method === 'greedy') {\n    source = source.filter(hasBounds);\n  }\n\n  // reset all items to be fully opaque\n  source.forEach(function (item) {\n    item.opacity = 1;\n  });\n\n  var items = source;\n\n  if (items.length >= 3 && hasOverlap(items)) {\n    pulse = pulse.reflow(_.modified()).modifies('opacity');\n    do {\n      items = reduce(items);\n    } while (items.length >= 3 && hasOverlap(items));\n\n    if (items.length < 3 && !(0, _vegaUtil.peek)(source).opacity) {\n      if (items.length > 1) (0, _vegaUtil.peek)(items).opacity = 0;\n      (0, _vegaUtil.peek)(source).opacity = 1;\n    }\n  }\n\n  if (_.boundScale) {\n    var test = boundTest(_.boundScale, _.boundOrient, _.boundTolerance);\n    source.forEach(function (item) {\n      if (!test(item)) item.opacity = 0;\n    });\n  }\n\n  return pulse;\n};"},"hash":"7fb3c80402b46d4e82d3d1d963aef068","cacheData":{"env":{}}}