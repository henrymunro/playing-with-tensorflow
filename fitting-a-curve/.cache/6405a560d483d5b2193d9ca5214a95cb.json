{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-encode/package.json","includedInParent":true,"mtime":1520281405000},{"name":"./ticks","loc":{"line":1,"column":24}},{"name":"vega-dataflow","loc":{"line":2,"column":24}},{"name":"vega-util","loc":{"line":6,"column":7}},{"name":"./scale-types","loc":{"line":13,"column":7}},{"name":"vega-scale","loc":{"line":21,"column":7}},{"name":"d3-interpolate","loc":{"line":27,"column":7}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Scale;\n\nvar _ticks = require('./ticks');\n\nvar _vegaDataflow = require('vega-dataflow');\n\nvar _vegaUtil = require('vega-util');\n\nvar _scaleTypes = require('./scale-types');\n\nvar _vegaScale = require('vega-scale');\n\nvar _d3Interpolate = require('d3-interpolate');\n\nvar DEFAULT_COUNT = 5;\n\nvar INCLUDE_ZERO = (0, _vegaUtil.toSet)([_scaleTypes.Linear, _scaleTypes.Pow, _scaleTypes.Sqrt]);\n\nvar INCLUDE_PAD = (0, _vegaUtil.toSet)([_scaleTypes.Linear, _scaleTypes.Log, _scaleTypes.Pow, _scaleTypes.Sqrt, _scaleTypes.Time, _scaleTypes.Utc]);\n\nvar SKIP = (0, _vegaUtil.toSet)(['set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount', 'domain', 'domainMin', 'domainMid', 'domainMax', 'domainRaw', 'nice', 'zero', 'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma']);\n\n/**\n * Maintains a scale function mapping data values to visual channels.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\nfunction Scale(params) {\n  _vegaDataflow.Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\n\nvar prototype = (0, _vegaUtil.inherits)(Scale, _vegaDataflow.Transform);\n\nprototype.transform = function (_, pulse) {\n  var df = pulse.dataflow,\n      scale = this.value,\n      prop;\n\n  if (!scale || _.modified('type')) {\n    this.value = scale = (0, _vegaScale.scale)((_.type || _scaleTypes.Linear).toLowerCase())();\n  }\n\n  for (prop in _) if (!SKIP[prop]) {\n    // padding is a scale property for band/point but not others\n    if (prop === 'padding' && INCLUDE_PAD[scale.type]) continue;\n    // invoke scale property setter, raise warning if not found\n    (0, _vegaUtil.isFunction)(scale[prop]) ? scale[prop](_[prop]) : df.warn('Unsupported scale property: ' + prop);\n  }\n\n  configureRange(scale, _, configureDomain(scale, _, df));\n\n  return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n};\n\nfunction configureDomain(scale, _, df) {\n  // check raw domain, if provided use that and exit early\n  var raw = rawDomain(scale, _.domainRaw);\n  if (raw > -1) return raw;\n\n  var domain = _.domain,\n      type = scale.type,\n      zero = _.zero || _.zero === undefined && INCLUDE_ZERO[type],\n      n,\n      mid;\n\n  if (!domain) return 0;\n\n  // adjust continuous domain for minimum pixel padding\n  if (INCLUDE_PAD[type] && _.padding && domain[0] !== (0, _vegaUtil.peek)(domain)) {\n    domain = padDomain(type, domain, _.range, _.padding, _.exponent);\n  }\n\n  // adjust domain based on zero, min, max settings\n  if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {\n    n = (domain = domain.slice()).length - 1 || 1;\n    if (zero) {\n      if (domain[0] > 0) domain[0] = 0;\n      if (domain[n] < 0) domain[n] = 0;\n    }\n    if (_.domainMin != null) domain[0] = _.domainMin;\n    if (_.domainMax != null) domain[n] = _.domainMax;\n\n    if (_.domainMid != null) {\n      mid = _.domainMid;\n      if (mid < domain[0] || mid > domain[n]) {\n        df.warn('Scale domainMid exceeds domain min or max.', mid);\n      }\n      domain.splice(n, 0, mid);\n    }\n  }\n\n  // set the scale domain\n  scale.domain(domain);\n\n  // if ordinal scale domain is defined, prevent implicit\n  // domain construction as side-effect of scale lookup\n  if (type === _scaleTypes.Ordinal) {\n    scale.unknown(undefined);\n  }\n\n  // perform 'nice' adjustment as requested\n  if (_.nice && scale.nice) {\n    scale.nice(_.nice !== true && (0, _ticks.tickCount)(scale, _.nice) || null);\n  }\n\n  // return the cardinality of the domain\n  return domain.length;\n}\n\nfunction rawDomain(scale, raw) {\n  if (raw) {\n    scale.domain(raw);\n    return raw.length;\n  } else {\n    return -1;\n  }\n}\n\nfunction padDomain(type, domain, range, pad, exponent) {\n  var span = Math.abs((0, _vegaUtil.peek)(range) - range[0]),\n      frac = span / (span - 2 * pad),\n      d = type === _scaleTypes.Log ? (0, _vegaUtil.zoomLog)(domain, null, frac) : type === _scaleTypes.Sqrt ? (0, _vegaUtil.zoomPow)(domain, null, frac, 0.5) : type === _scaleTypes.Pow ? (0, _vegaUtil.zoomPow)(domain, null, frac, exponent) : (0, _vegaUtil.zoomLinear)(domain, null, frac);\n\n  domain = domain.slice();\n  domain[0] = d[0];\n  domain[domain.length - 1] = d[1];\n  return domain;\n}\n\nfunction configureRange(scale, _, count) {\n  var round = _.round || false,\n      range = _.range;\n\n  // if range step specified, calculate full range extent\n  if (_.rangeStep != null) {\n    range = configureRangeStep(scale.type, _, count);\n  }\n\n  // else if a range scheme is defined, use that\n  else if (_.scheme) {\n      range = configureScheme(scale.type, _, count);\n      if ((0, _vegaUtil.isFunction)(range)) return scale.interpolator(range);\n    }\n\n    // given a range array for a sequential scale, convert to interpolator\n    else if (range && scale.type === _scaleTypes.Sequential) {\n        return scale.interpolator((0, _d3Interpolate.interpolateRgbBasis)(flip(range, _.reverse)));\n      }\n\n  // configure rounding / interpolation\n  if (range && _.interpolate && scale.interpolate) {\n    scale.interpolate((0, _vegaScale.interpolate)(_.interpolate, _.interpolateGamma));\n  } else if ((0, _vegaUtil.isFunction)(scale.round)) {\n    scale.round(round);\n  } else if ((0, _vegaUtil.isFunction)(scale.rangeRound)) {\n    scale.interpolate(round ? _d3Interpolate.interpolateRound : _d3Interpolate.interpolate);\n  }\n\n  if (range) scale.range(flip(range, _.reverse));\n}\n\nfunction configureRangeStep(type, _, count) {\n  if (type !== _scaleTypes.Band && type !== _scaleTypes.Point) {\n    (0, _vegaUtil.error)('Only band and point scales support rangeStep.');\n  }\n\n  // calculate full range based on requested step size and padding\n  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,\n      inner = type === _scaleTypes.Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;\n  return [0, _.rangeStep * (0, _vegaScale.bandSpace)(count, inner, outer)];\n}\n\nfunction configureScheme(type, _, count) {\n  var name = _.scheme.toLowerCase(),\n      scheme = (0, _vegaScale.scheme)(name),\n      extent = _.schemeExtent,\n      discrete;\n\n  if (!scheme) {\n    (0, _vegaUtil.error)('Unrecognized scheme name: ' + _.scheme);\n  }\n\n  // determine size for potential discrete range\n  count = type === _scaleTypes.Threshold ? count + 1 : type === _scaleTypes.BinOrdinal ? count - 1 : type === _scaleTypes.Quantile || type === _scaleTypes.Quantize ? +_.schemeCount || DEFAULT_COUNT : count;\n\n  // adjust and/or quantize scheme as appropriate\n  return type === _scaleTypes.Sequential ? adjustScheme(scheme, extent, _.reverse) : !extent && (discrete = (0, _vegaScale.scheme)(name + '-' + count)) ? discrete : (0, _vegaUtil.isFunction)(scheme) ? quantize(adjustScheme(scheme, extent), count) : type === _scaleTypes.Ordinal ? scheme : scheme.slice(0, count);\n}\n\nfunction adjustScheme(scheme, extent, reverse) {\n  return (0, _vegaUtil.isFunction)(scheme) && (extent || reverse) ? (0, _vegaScale.interpolateRange)(scheme, flip(extent || [0, 1], reverse)) : scheme;\n}\n\nfunction flip(array, reverse) {\n  return reverse ? array.slice().reverse() : array;\n}\n\nfunction quantize(interpolator, count) {\n  var samples = new Array(count),\n      n = count - 1 || 1;\n  for (var i = 0; i < count; ++i) samples[i] = interpolator(i / n);\n  return samples;\n}"},"hash":"3c651b8c7de839c4e6469b3266715760","cacheData":{"env":{}}}