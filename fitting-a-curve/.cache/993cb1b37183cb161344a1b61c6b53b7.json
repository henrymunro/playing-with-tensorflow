{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-dataflow/package.json","includedInParent":true,"mtime":1518291445000},{"name":"../Pulse","loc":{"line":1,"column":48}},{"name":"../MultiPulse","loc":{"line":2,"column":23}},{"name":"../util/UniqueList","loc":{"line":3,"column":23}},{"name":"vega-util","loc":{"line":4,"column":39}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = run;\nexports.runAsync = runAsync;\nexports.runAfter = runAfter;\nexports.enqueue = enqueue;\nexports.getPulse = getPulse;\n\nvar _Pulse = require('../Pulse');\n\nvar _Pulse2 = _interopRequireDefault(_Pulse);\n\nvar _MultiPulse = require('../MultiPulse');\n\nvar _MultiPulse2 = _interopRequireDefault(_MultiPulse);\n\nvar _UniqueList = require('../util/UniqueList');\n\nvar _UniqueList2 = _interopRequireDefault(_UniqueList);\n\nvar _vegaUtil = require('vega-util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Runs the dataflow. This method will increment the current timestamp\n * and process all updated, pulsed and touched operators. When run for\n * the first time, all registered operators will be processed. If there\n * are pending data loading operations, this method will return immediately\n * without evaluating the dataflow. Instead, the dataflow will be\n * asynchronously invoked when data loading completes. To track when dataflow\n * evaluation completes, use the {@link runAsync} method instead.\n * @param {string} [encode] - The name of an encoding set to invoke during\n *   propagation. This value is added to generated Pulse instances;\n *   operators can then respond to (or ignore) this setting as appropriate.\n *   This parameter can be used in conjunction with the Encode transform in\n *   the vega-encode module.\n */\nfunction run(encode) {\n  var df = this,\n      count = 0,\n      level = df.logLevel(),\n      op,\n      next,\n      dt,\n      error;\n\n  if (df._pending) {\n    df.info('Awaiting requests, delaying dataflow run.');\n    return 0;\n  }\n\n  if (df._pulse) {\n    df.error('Dataflow invoked recursively. Use the runAfter method to queue invocation.');\n    return 0;\n  }\n\n  if (!df._touched.length) {\n    df.info('Dataflow invoked, but nothing to do.');\n    return 0;\n  }\n\n  df._pulse = new _Pulse2.default(df, ++df._clock, encode);\n\n  if (level >= _vegaUtil.Info) {\n    dt = Date.now();\n    df.debug('-- START PROPAGATION (' + df._clock + ') -----');\n  }\n\n  // initialize queue, reset touched operators\n  df._touched.forEach(function (op) {\n    df._enqueue(op, true);\n  });\n  df._touched = (0, _UniqueList2.default)(_vegaUtil.id);\n\n  try {\n    while (df._heap.size() > 0) {\n      op = df._heap.pop();\n\n      // re-queue if rank changes\n      if (op.rank !== op.qrank) {\n        df._enqueue(op, true);continue;\n      }\n\n      // otherwise, evaluate the operator\n      next = op.run(df._getPulse(op, encode));\n\n      if (level >= _vegaUtil.Debug) {\n        df.debug(op.id, next === _Pulse.StopPropagation ? 'STOP' : next, op);\n      }\n\n      // propagate the pulse\n      if (next !== _Pulse.StopPropagation) {\n        df._pulse = next;\n        if (op._targets) op._targets.forEach(function (op) {\n          df._enqueue(op);\n        });\n      }\n\n      // increment visit counter\n      ++count;\n    }\n  } catch (err) {\n    error = err;\n  }\n\n  // reset pulse map\n  df._pulses = {};\n  df._pulse = null;\n\n  if (level >= _vegaUtil.Info) {\n    dt = Date.now() - dt;\n    df.info('> Pulse ' + df._clock + ': ' + count + ' operators; ' + dt + 'ms');\n  }\n\n  if (error) {\n    df._postrun = [];\n    df.error(error);\n  }\n\n  if (df._onrun) {\n    try {\n      df._onrun(df, count, error);\n    } catch (err) {\n      df.error(err);\n    }\n  }\n\n  // invoke callbacks queued via runAfter\n  if (df._postrun.length) {\n    var postrun = df._postrun;\n    df._postrun = [];\n    postrun.sort(function (a, b) {\n      return b.priority - a.priority;\n    }).forEach(function (_) {\n      invokeCallback(df, _.callback);\n    });\n  }\n\n  return count;\n}\n\nfunction invokeCallback(df, callback) {\n  try {\n    callback(df);\n  } catch (err) {\n    df.error(err);\n  }\n}\n\n/**\n * Runs the dataflow and returns a Promise that resolves when the\n * propagation cycle completes. The standard run method may exit early\n * if there are pending data loading operations. In contrast, this\n * method returns a Promise to allow callers to receive notification\n * when dataflow evaluation completes.\n * @return {Promise} - A promise that resolves to this dataflow.\n */\nfunction runAsync() {\n  return this._pending || Promise.resolve(this.run());\n}\n\n/**\n * Schedules a callback function to be invoked after the current pulse\n * propagation completes. If no propagation is currently occurring,\n * the function is invoked immediately.\n * @param {function(Dataflow)} callback - The callback function to run.\n *   The callback will be invoked with this Dataflow instance as its\n *   sole argument.\n * @param {boolean} enqueue - A boolean flag indicating that the\n *   callback should be queued up to run after the next propagation\n *   cycle, suppressing immediate invocation when propagation is not\n *   currently occurring.\n */\nfunction runAfter(callback, enqueue, priority) {\n  if (this._pulse || enqueue) {\n    // pulse propagation is currently running, queue to run after\n    this._postrun.push({\n      priority: priority || 0,\n      callback: callback\n    });\n  } else {\n    // pulse propagation already complete, invoke immediately\n    invokeCallback(this, callback);\n  }\n}\n\n/**\n * Enqueue an operator into the priority queue for evaluation. The operator\n * will be enqueued if it has no registered pulse for the current cycle, or if\n * the force argument is true. Upon enqueue, this method also sets the\n * operator's qrank to the current rank value.\n * @param {Operator} op - The operator to enqueue.\n * @param {boolean} [force] - A flag indicating if the operator should be\n *   forceably added to the queue, even if it has already been previously\n *   enqueued during the current pulse propagation. This is useful when the\n *   dataflow graph is dynamically modified and the operator rank changes.\n */\nfunction enqueue(op, force) {\n  var p = !this._pulses[op.id];\n  if (p) this._pulses[op.id] = this._pulse;\n  if (p || force) {\n    op.qrank = op.rank;\n    this._heap.push(op);\n  }\n}\n\n/**\n * Provide a correct pulse for evaluating an operator. If the operator has an\n * explicit source operator, we will try to pull the pulse(s) from it.\n * If there is an array of source operators, we build a multi-pulse.\n * Otherwise, we return a current pulse with correct source data.\n * If the pulse is the pulse map has an explicit target set, we use that.\n * Else if the pulse on the upstream source operator is current, we use that.\n * Else we use the pulse from the pulse map, but copy the source tuple array.\n * @param {Operator} op - The operator for which to get an input pulse.\n * @param {string} [encode] - An (optional) encoding set name with which to\n *   annotate the returned pulse. See {@link run} for more information.\n */\nfunction getPulse(op, encode) {\n  var s = op.source,\n      stamp = this._clock,\n      p;\n\n  if (s && (0, _vegaUtil.isArray)(s)) {\n    p = s.map(function (_) {\n      return _.pulse;\n    });\n    return new _MultiPulse2.default(this, stamp, p, encode);\n  }\n\n  p = this._pulses[op.id];\n  if (s) {\n    s = s.pulse;\n    if (!s || s === _Pulse.StopPropagation) {\n      p.source = [];\n    } else if (s.stamp === stamp && p.target !== op) {\n      p = s;\n    } else {\n      p.source = s.source;\n    }\n  }\n\n  return p;\n}"},"hash":"d268dffdf69d5571c8a1321543dcffa2","cacheData":{"env":{}}}