{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-transforms/package.json","includedInParent":true,"mtime":1520278057000},{"name":"./Aggregate","loc":{"line":1,"column":22}},{"name":"./util/AggregateOps","loc":{"line":2,"column":32}},{"name":"vega-util","loc":{"line":3,"column":49}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Pivot;\n\nvar _Aggregate = require('./Aggregate');\n\nvar _Aggregate2 = _interopRequireDefault(_Aggregate);\n\nvar _AggregateOps = require('./util/AggregateOps');\n\nvar _vegaUtil = require('vega-util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Aggregate and pivot selected field values to become new fields.\n * This operator is useful to construction cross-tabulations.\n * @constructor\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *  to groupby. These fields act just like groupby fields of an Aggregate transform.\n * @param {function(object): *} params.field - The field to pivot on. The unique\n *  values of this field become new field names in the output stream.\n * @param {function(object): *} params.value - The field to populate pivoted fields.\n *  The aggregate values of this field become the values of the new pivoted fields.\n * @param {string} [params.op] - The aggregation operation for the value field,\n *  applied per cell in the output stream. The default is \"sum\".\n * @param {number} [params.limit] - An optional parameter indicating the maximum\n *  number of pivoted fields to generate. The pivoted field names are sorted in\n *  ascending order prior to enforcing the limit.\n */\nfunction Pivot(params) {\n  _Aggregate2.default.call(this, params);\n}\n\nPivot.Definition = {\n  \"type\": \"Pivot\",\n  \"metadata\": { \"generates\": true, \"changes\": true },\n  \"params\": [{ \"name\": \"groupby\", \"type\": \"field\", \"array\": true }, { \"name\": \"field\", \"type\": \"field\", \"required\": true }, { \"name\": \"value\", \"type\": \"field\", \"required\": true }, { \"name\": \"op\", \"type\": \"enum\", \"values\": _AggregateOps.ValidAggregateOps, \"default\": \"sum\" }, { \"name\": \"limit\", \"type\": \"number\", \"default\": 0 }, { \"name\": \"key\", \"type\": \"field\" }]\n};\n\nvar prototype = (0, _vegaUtil.inherits)(Pivot, _Aggregate2.default);\n\nprototype._transform = prototype.transform;\n\nprototype.transform = function (_, pulse) {\n  return this._transform(aggregateParams(_, pulse), pulse);\n};\n\n// Shoehorn a pivot transform into an aggregate transform!\n// First collect all unique pivot field values.\n// Then generate aggregate fields for each output pivot field.\nfunction aggregateParams(_, pulse) {\n  var key = _.field,\n      value = _.value,\n      op = (_.op === 'count' ? '__count__' : _.op) || 'sum',\n      fields = (0, _vegaUtil.accessorFields)(key).concat((0, _vegaUtil.accessorFields)(value)),\n      keys = pivotKeys(key, _.limit || 0, pulse);\n\n  return {\n    key: _.key,\n    groupby: _.groupby,\n    ops: keys.map(function () {\n      return op;\n    }),\n    fields: keys.map(function (k) {\n      return get(k, key, value, fields);\n    }),\n    as: keys.map(function (k) {\n      return k + '';\n    }),\n    modified: _.modified.bind(_)\n  };\n}\n\n// Generate aggregate field accessor.\n// Output NaN for non-existent values; aggregator will ignore!\nfunction get(k, key, value, fields) {\n  return (0, _vegaUtil.accessor)(function (d) {\n    return key(d) === k ? value(d) : NaN;\n  }, fields, k + '');\n}\n\n// Collect (and optionally limit) all unique pivot values.\nfunction pivotKeys(key, limit, pulse) {\n  var map = {},\n      list = [];\n\n  pulse.visit(pulse.SOURCE, function (t) {\n    var k = key(t);\n    if (!map[k]) {\n      map[k] = 1;\n      list.push(k);\n    }\n  });\n\n  // TODO? Move this comparator to vega-util?\n  list.sort(function (u, v) {\n    return (u < v || u == null) && v != null ? -1 : (u > v || v == null) && u != null ? 1 : (v = v instanceof Date ? +v : v, u = u instanceof Date ? +u : u) !== u && v === v ? -1 : v !== v && u === u ? 1 : 0;\n  });\n\n  return limit ? list.slice(0, limit) : list;\n}"},"hash":"f84889b9726ca1ec6bc2bb61e86436cf","cacheData":{"env":{}}}