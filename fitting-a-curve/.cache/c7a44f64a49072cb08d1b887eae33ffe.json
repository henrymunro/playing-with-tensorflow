{"dependencies":[{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/package.json","includedInParent":true,"mtime":1522495589000},{"name":"/Users/senecamac1/henry/playing-with-tensorflow/fitting-a-curve/node_modules/vega-parser/package.json","includedInParent":true,"mtime":1520359126000},{"name":"./transform","loc":{"line":1,"column":27}},{"name":"./trigger","loc":{"line":2,"column":25}},{"name":"../util","loc":{"line":3,"column":18}},{"name":"../transforms","loc":{"line":4,"column":36}},{"name":"vega-util","loc":{"line":5,"column":20}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseData;\n\nvar _transform = require('./transform');\n\nvar _transform2 = _interopRequireDefault(_transform);\n\nvar _trigger = require('./trigger');\n\nvar _trigger2 = _interopRequireDefault(_trigger);\n\nvar _util = require('../util');\n\nvar _transforms = require('../transforms');\n\nvar _vegaUtil = require('vega-util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parseData(data, scope) {\n  var transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(function (tx) {\n      transforms.push((0, _transform2.default)(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(function (on) {\n      (0, _trigger2.default)(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n\n/**\n * Analyze a data pipeline, add needed operators.\n */\nfunction analyze(data, scope, ops) {\n  // POSSIBLE TODOs:\n  // - error checking for treesource on tree operators (BUT what if tree is upstream?)\n  // - this is local analysis, perhaps some tasks better for global analysis...\n\n  var output = [],\n      source = null,\n      modify = false,\n      generate = false,\n      upstream,\n      i,\n      n,\n      t,\n      m;\n\n  if (data.values) {\n    // hard-wired input data set\n    output.push(source = collect({ $ingest: data.values, $format: data.format }));\n  } else if (data.url) {\n    // load data from external source\n    output.push(source = collect({ $request: data.url, $format: data.format }));\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = (0, _vegaUtil.array)(data.source).map(function (d) {\n      return (0, _util.ref)(scope.getData(d).output);\n    });\n    output.push(null); // populate later\n  }\n\n  // scan data transforms, add collectors as needed\n  for (i = 0, n = ops.length; i < n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n    output.push(t);\n\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n\n    if (m.source) source = t;else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = (0, _transforms.Relay)({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push((0, _transforms.Sieve)({}));\n  return output;\n}\n\nfunction collect(values) {\n  var s = (0, _transforms.Collect)({}, values);\n  s.metadata = { source: true };\n  return s;\n}"},"hash":"263fefe2fa437231ca19c9cbe4412c52","cacheData":{"env":{}}}